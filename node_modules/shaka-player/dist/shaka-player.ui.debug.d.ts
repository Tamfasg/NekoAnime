/*! @license
 * Shaka Player
 * Copyright 2016 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

declare class GlobalError extends Error {}

//!! generated by clutz.
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka {
  class Player extends shaka.util.FakeEventTarget implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_Player : any;
    constructor (mediaElement ? : HTMLMediaElement | null , dependencyInjector ? : (a : shaka.Player | null ) => any ) ;
    /**
     * Adds the given chapters track to the loaded manifest.  <code>load()</code>
     * must resolve before calling.  The presentation must have a duration.
     * This returns the created track.
     */
    addChaptersTrack (uri : string , language : string , mimeType ? : string ) : Promise < shaka.extern.Track > ;
    /**
     * Adds the given text track to the loaded manifest.  <code>load()</code> must
     * resolve before calling.  The presentation must have a duration.
     * This returns the created track, which can immediately be selected by the
     * application.  The track will not be automatically selected.
     */
    addTextTrackAsync (uri : string , language : string , kind : string , mimeType ? : string , codec ? : string , label ? : string , forced ? : boolean ) : Promise < shaka.extern.Track > ;
    /**
     * Adds the given thumbnails track to the loaded manifest.
     * <code>load()</code> must resolve before calling.  The presentation must
     * have a duration.
     * This returns the created track, which can immediately be used by the
     * application.
     */
    addThumbnailsTrack (uri : string , mimeType ? : string ) : Promise < shaka.extern.Track > ;
    /**
     * Tell the player to use <code>mediaElement</code> for all <code>load</code>
     * requests until <code>detach</code> or <code>destroy</code> are called.
     * <p>
     * Calling <code>attach</code> with <code>initializedMediaSource=true</code>
     * will tell the player to take the initial load step and initialize media
     * source.
     * <p>
     * Calls to <code>attach</code> will interrupt any in-progress calls to
     * <code>load</code> but cannot interrupt calls to <code>attach</code>,
     * <code>detach</code>, or <code>unload</code>.
     */
    attach (mediaElement : HTMLMediaElement , initializeMediaSource ? : boolean ) : Promise < any > ;
    /**
     * Calling <code>attachCanvas</code> will tell the player to set canvas
     * element for LCEVC decoding.
     */
    attachCanvas (canvas : HTMLCanvasElement | null ) : any ;
    /**
     * Cancel trick-play. If the player has not loaded content or is still loading
     * content this will be a no-op.
     */
    cancelTrickPlay ( ) : any ;
    /**
     * Changes configuration settings on the Player.  This checks the names of
     * keys and the types of values to avoid coding errors.  If there are errors,
     * this logs them to the console and returns false.  Correct fields are still
     * applied even if there are other errors.  You can pass an explicit
     * <code>undefined</code> value to restore the default value.  This has two
     * modes of operation:
     * <p>
     * First, this can be passed a single "plain" object.  This object should
     * follow the {@link shaka.extern.PlayerConfiguration} object.  Not all fields
     * need to be set; unset fields retain their old values.
     * <p>
     * Second, this can be passed two arguments.  The first is the name of the key
     * to set.  This should be a '.' separated path to the key.  For example,
     * <code>'streaming.alwaysStreamText'</code>.  The second argument is the
     * value to set.
     * @param config This should either be a field name or an object.
     * @param value In the second mode, this is the value to set.
     */
    configure (config : string | object , value ? : any ) : boolean ;
    /**
     * After destruction, a Player object cannot be used again.
     */
    destroy ( ) : Promise < any > ;
    /**
     * Tell the player to stop using its current media element. If the player is:
     * <ul>
     * <li>detached, this will do nothing,
     * <li>attached, this will release the media element,
     * <li>loading, this will abort loading, unload, and release the media
     * element,
     * <li>playing content, this will stop playback, unload, and release the
     * media element.
     * </ul>
     * <p>
     * Calls to <code>detach</code> will interrupt any in-progress calls to
     * <code>load</code> but cannot interrupt calls to <code>attach</code>,
     * <code>detach</code>, or <code>unload</code>.
     */
    detach ( ) : Promise < any > ;
    /**
     * Get the drm info used to initialize EME. If EME is not being used, this
     * will return <code>null</code>. If the player is idle or has not initialized
     * EME yet, this will return <code>null</code>.
     */
    drmInfo ( ) : shaka.extern.DrmInfo | null ;
    /**
     * Returns the active sessions metadata
     */
    getActiveSessionsMetadata ( ) : shaka.extern.DrmSessionMetadata [] ;
    /**
     * Returns a shaka.ads.AdManager instance, responsible for Dynamic
     * Ad Insertion functionality.
     */
    getAdManager ( ) : shaka.extern.IAdManager | null ;
    /**
     * Get the uri to the asset that the player has loaded. If the player has not
     * loaded content, this will return <code>null</code>.
     */
    getAssetUri ( ) : string | null ;
    /**
     * Return a list of audio languages available. If the player has not loaded
     * any content, this will return an empty list.
     */
    getAudioLanguages ( ) : string [] ;
    /**
     * Return a list of audio language-role combinations available.  If the
     * player has not loaded any content, this will return an empty list.
     */
    getAudioLanguagesAndRoles ( ) : shaka.extern.LanguageRole [] ;
    /**
     * Returns the ratio of video length buffered compared to buffering Goal
     */
    getBufferFullness ( ) : number ;
    /**
     * Get information about what the player has buffered. If the player has not
     * loaded content or is currently loading content, the buffered content will
     * be empty.
     */
    getBufferedInfo ( ) : shaka.extern.BufferedInfo ;
    /**
     * This returns the list of chapters.
     */
    getChapters (language : string ) : shaka.extern.Chapter [] ;
    /**
     * Return a list of chapters tracks.
     */
    getChaptersTracks ( ) : shaka.extern.TrackList ;
    /**
     * Return a copy of the current configuration.  Modifications of the returned
     * value will not affect the Player's active configuration.  You must call
     * <code>player.configure()</code> to make changes.
     */
    getConfiguration ( ) : shaka.extern.PlayerConfiguration ;
    /**
     * Get the next known expiration time for any EME session. If the session
     * never expires, this will return <code>Infinity</code>. If there are no EME
     * sessions, this will return <code>Infinity</code>. If the player has not
     * loaded content, this will return <code>Infinity</code>.
     */
    getExpiration ( ) : number ;
    /**
     * Return a list of image tracks that can be switched to.
     * If the player has not loaded content, this will return an empty list.
     */
    getImageTracks ( ) : shaka.extern.TrackList ;
    /**
     * Gets a map of EME key ID to the current key status.
     */
    getKeyStatuses ( ) : { [ key: string ]: string } ;
    /**
     * Get the current load mode.
     */
    getLoadMode ( ) : shaka.Player.LoadMode ;
    /**
     * Get the manifest that the player has loaded. If the player has not loaded
     * any content, this will return <code>null</code>.
     * NOTE: This structure is NOT covered by semantic versioning compatibility
     * guarantees.  It may change at any time!
     * This is marked as deprecated to warn Closure Compiler users at compile-time
     * to avoid using this method.
     */
    getManifest ( ) : shaka.extern.Manifest | null ;
    /**
     * Get the type of manifest parser that the player is using. If the player has
     * not loaded any content, this will return <code>null</code>.
     */
    getManifestParserFactory ( ) : ( shaka.extern.ManifestParser.Factory ) | null ;
    /**
     * Get the current manifest type.
     */
    getManifestType ( ) : string | null ;
    /**
     * Get the media element that the player is currently using to play loaded
     * content. If the player has not loaded content, this will return
     * <code>null</code>.
     */
    getMediaElement ( ) : HTMLMediaElement | null ;
    getNetworkingEngine ( ) : shaka.net.NetworkingEngine | null ;
    /**
     * Get the playback rate of what is playing right now. If we are using trick
     * play, this will return the trick play rate.
     * If no content is playing, this will return 0.
     * If content is buffering, this will return the expected playback rate once
     * the video starts playing.
     * <p>
     * If the player has not loaded content, this will return a playback rate of
     * 0.
     */
    getPlaybackRate ( ) : number ;
    /**
     * Get the current playhead position as a date. This should only be called
     * when the player has loaded a live stream. If the player has not loaded a
     * live stream, this will return <code>null</code>.
     */
    getPlayheadTimeAsDate ( ) : Date | null ;
    /**
     * Get the presentation start time as a date. This should only be called when
     * the player has loaded a live stream. If the player has not loaded a live
     * stream, this will return <code>null</code>.
     */
    getPresentationStartTimeAsDate ( ) : Date | null ;
    /**
     * Get statistics for the current playback session. If the player is not
     * playing content, this will return an empty stats object.
     */
    getStats ( ) : shaka.extern.Stats ;
    /**
     * Return a list of text languages available. If the player has not loaded
     * any content, this will return an empty list.
     */
    getTextLanguages ( ) : string [] ;
    /**
     * Return a list of text language-role combinations available.  If the player
     * has not loaded any content, this will be return an empty list.
     */
    getTextLanguagesAndRoles ( ) : shaka.extern.LanguageRole [] ;
    /**
     * Return a list of text tracks that can be switched to.
     * <p>
     * If the player has not loaded content, this will return an empty list.
     */
    getTextTracks ( ) : shaka.extern.TrackList ;
    /**
     * Return a Thumbnail object from a image track Id and time.
     * If the player has not loaded content, this will return a null.
     */
    getThumbnails (trackId : number , time : number ) : Promise < shaka.extern.Thumbnail | null > ;
    /**
     * Return a list of variant tracks that can be switched to.
     * <p>
     * If the player has not loaded content, this will return an empty list.
     */
    getVariantTracks ( ) : shaka.extern.TrackList ;
    /**
     * Go to live in a live stream.
     */
    goToLive ( ) : any ;
    /**
     * Check if the manifest contains only audio-only content. If the player has
     * not loaded content, this will return <code>false</code>.
     * <p>
     * The player does not support content that contain more than one type of
     * variants (i.e. mixing audio-only, video-only, audio-video). Content will be
     * filtered to only contain one type of variant.
     */
    isAudioOnly ( ) : boolean ;
    /**
     * Check if the player is currently in a buffering state (has too little
     * content to play smoothly). If the player has not loaded content, this will
     * return <code>false</code>.
     */
    isBuffering ( ) : boolean ;
    /**
     * Get if the player is playing in-progress content. If the player has not
     * loaded content, this will return <code>false</code>.
     */
    isInProgress ( ) : boolean ;
    /**
     * Get if the player is playing live content. If the player has not loaded
     * content, this will return <code>false</code>.
     */
    isLive ( ) : boolean ;
    /**
     * Check if the text displayer is enabled.
     */
    isTextTrackVisible ( ) : boolean ;
    /**
     * Get the key system currently used by EME. If EME is not being used, this
     * will return an empty string. If the player has not loaded content, this
     * will return an empty string.
     */
    keySystem ( ) : string ;
    /**
     * Tell the player to load the content at <code>assetUri</code> and start
     * playback at <code>startTime</code>. Before calling <code>load</code>,
     * a call to <code>attach</code> must have succeeded.
     * <p>
     * Calls to <code>load</code> will interrupt any in-progress calls to
     * <code>load</code> but cannot interrupt calls to <code>attach</code>,
     * <code>detach</code>, or <code>unload</code>.
     * @param startTime When <code>startTime</code> is <code>null</code> or <code>undefined</code>, playback will start at the default start time (0 for VOD and liveEdge for LIVE).
     */
    load (assetUri : string , startTime ? : number | null , mimeType ? : string ) : Promise < any > ;
    /**
     * Reset configuration to default.
     */
    resetConfiguration ( ) : any ;
    /**
     * Retry streaming after a streaming failure has occurred. When the player has
     * not loaded content or is loading content, this will be a no-op and will
     * return <code>false</code>.
     * <p>
     * If the player has loaded content, and streaming has not seen an error, this
     * will return <code>false</code>.
     * <p>
     * If the player has loaded content, and streaming seen an error, but the
     * could not resume streaming, this will return <code>false</code>.
     */
    retryStreaming (retryDelaySeconds ? : number ) : boolean ;
    /**
     * Get the range of time (in seconds) that seeking is allowed. If the player
     * has not loaded content, this will return a range from 0 to 0.
     */
    seekRange ( ) : shaka.extern.BufferedRange ;
    /**
     * Sets the current audio language and current variant role to the selected
     * language, role and channel count, and chooses a new variant if need be.
     * If the player has not loaded any content, this will be a no-op.
     */
    selectAudioLanguage (language : string , role ? : string , channelsCount ? : number , safeMargin ? : number ) : any ;
    /**
     * Sets the current text language and current text role to the selected
     * language and role, and chooses a new variant if need be. If the player has
     * not loaded any content, this will be a no-op.
     */
    selectTextLanguage (language : string , role ? : string , forced ? : boolean ) : any ;
    /**
     * Select a specific text track. <code>track</code> should come from a call to
     * <code>getTextTracks</code>. If the track is not found, this will be a
     * no-op. If the player has not loaded content, this will be a no-op.
     * <p>
     * Note that <code>AdaptationEvents</code> are not fired for manual track
     * selections.
     */
    selectTextTrack (track : shaka.extern.Track ) : any ;
    /**
     * Select a specific variant track to play.  <code>track</code> should come
     * from a call to <code>getVariantTracks</code>. If <code>track</code> cannot
     * be found, this will be a no-op. If the player has not loaded content, this
     * will be a no-op.
     * <p>
     * Changing variants will take effect once the currently buffered content has
     * been played. To force the change to happen sooner, use
     * <code>clearBuffer</code> with <code>safeMargin</code>. Setting
     * <code>clearBuffer</code> to <code>true</code> will clear all buffered
     * content after <code>safeMargin</code>, allowing the new variant to start
     * playing sooner.
     * <p>
     * Note that <code>AdaptationEvents</code> are not fired for manual track
     * selections.
     * @param safeMargin Optional amount of buffer (in seconds) to retain when clearing the buffer. Useful for switching variant quickly without causing a buffering event. Defaults to 0 if not provided. Ignored if clearBuffer is false. Can cause hiccups on some browsers if chosen too small, e.g. The amount of two segments is a fair minimum to consider as safeMargin value.
     */
    selectVariantTrack (track : shaka.extern.Track , clearBuffer ? : boolean , safeMargin ? : number ) : any ;
    /**
     * Select variant tracks that have a given label. This assumes the
     * label uniquely identifies an audio stream, so all the variants
     * are expected to have the same variant.audio.
     * @param clearBuffer Optional clear buffer or not when switch to new variant Defaults to true if not provided
     * @param safeMargin Optional amount of buffer (in seconds) to retain when clearing the buffer. Defaults to 0 if not provided. Ignored if clearBuffer is false.
     */
    selectVariantsByLabel (label : string , clearBuffer ? : boolean , safeMargin ? : number ) : any ;
    /**
     * Set the maximum resolution that the platform's hardware can handle.
     * This will be called automatically by <code>shaka.cast.CastReceiver</code>
     * to enforce limitations of the Chromecast hardware.
     */
    setMaxHardwareResolution (width : number , height : number ) : any ;
    /**
     * Enable or disable the text displayer.  If the player is in an unloaded
     * state, the request will be applied next time content is loaded.
     */
    setTextTrackVisibility (isVisible : boolean ) : any ;
    /**
     * Set the videoContainer to construct UITextDisplayer.
     */
    setVideoContainer (videoContainer : HTMLElement | null ) : any ;
    /**
     * Enable trick play to skip through content without playing by repeatedly
     * seeking. For example, a rate of 2.5 would result in 2.5 seconds of content
     * being skipped every second. A negative rate will result in moving
     * backwards.
     * <p>
     * If the player has not loaded content or is still loading content this will
     * be a no-op. Wait until <code>load</code> has completed before calling.
     * <p>
     * Trick play will be canceled automatically if the playhead hits the
     * beginning or end of the seekable range for the content.
     */
    trickPlay (rate : number ) : any ;
    /**
     * Tell the player to either return to:
     * <ul>
     * <li>detached (when it does not have a media element),
     * <li>attached (when it has a media element and
     * <code>initializedMediaSource=false</code>)
     * <li>media source initialized (when it has a media element and
     * <code>initializedMediaSource=true</code>)
     * </ul>
     * <p>
     * Calls to <code>unload</code> will interrupt any in-progress calls to
     * <code>load</code> but cannot interrupt calls to <code>attach</code>,
     * <code>detach</code>, or <code>unload</code>.
     */
    unload (initializeMediaSource ? : boolean ) : Promise < any > ;
    /**
     * Provides a way to update the stream start position during the media loading
     * process. Can for example be called from the <code>manifestparsed</code>
     * event handler to update the start position based on information in the
     * manifest.
     */
    updateStartTime (startTime : number ) : any ;
    /**
     * Return whether the browser provides basic support.  If this returns false,
     * Shaka Player cannot be used at all.  In this case, do not construct a
     * Player instance and do not use the library.
     */
    static isBrowserSupported ( ) : boolean ;
    /**
     * Probes the browser to determine what features are supported.  This makes a
     * number of requests to EME/MSE/etc which may result in user prompts.  This
     * should only be used for diagnostics.
     * <p>
     * NOTE: This may show a request to the user for permission.
     */
    static probeSupport (promptsOkay ? : boolean ) : Promise < shaka.extern.SupportType > ;
    /**
     * Registers a plugin callback that will be called with
     * <code>support()</code>.  The callback will return the value that will be
     * stored in the return value from <code>support()</code>.
     */
    static registerSupportPlugin (name : string , callback : ( ) => any ) : any ;
    /**
     * Set a factory to create an ad manager during player construction time.
     * This method needs to be called bafore instantiating the Player class.
     */
    static setAdManagerFactory (factory : shaka.extern.IAdManager.Factory ) : any ;
    static version : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.Player {
  /**
   * In order to know what method of loading the player used for some content, we
   * have this enum. It lets us know if content has not been loaded, loaded with
   * media source, or loaded with src equals.
   * This enum has a low resolution, because it is only meant to express the
   * outer limits of the various states that the player is in. For example, when
   * someone calls a public method on player, it should not matter if they have
   * initialized drm engine, it should only matter if they finished loading
   * content.
   */
  /**
   * In order to know what method of loading the player used for some content, we
   * have this enum. It lets us know if content has not been loaded, loaded with
   * media source, or loaded with src equals.
   * This enum has a low resolution, because it is only meant to express the
   * outer limits of the various states that the player is in. For example, when
   * someone calls a public method on player, it should not matter if they have
   * initialized drm engine, it should only matter if they finished loading
   * content.
   */
  enum LoadMode {
    DESTROYED = 0.0 ,
    MEDIA_SOURCE = 2.0 ,
    NOT_LOADED = 1.0 ,
    SRC_EQUALS = 3.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.abr {
  class SimpleAbrManager implements shaka.extern.AbrManager , shaka.util.IReleasable {
    private noStructuralTyping_shaka_abr_SimpleAbrManager : any;
    chooseVariant ( ) : any ;
    configure (config : any ) : any ;
    disable ( ) : any ;
    enable ( ) : any ;
    getBandwidthEstimate ( ) : any ;
    init (switchCallback : any ) : any ;
    playbackRateChanged (rate : any ) : any ;
    release ( ) : any ;
    segmentDownloaded (deltaTimeMs : any , numBytes : any ) : any ;
    setMediaElement (mediaElement : any ) : any ;
    setVariants (variants : any ) : any ;
    stop ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ads {
  /**
   * A class responsible for ad-related interactions.
   */
  class AdManager extends shaka.util.FakeEventTarget implements shaka.extern.IAdManager , shaka.util.IReleasable {
    private noStructuralTyping_shaka_ads_AdManager : any;
    configure (config : any ) : any ;
    getServerSideCuePoints ( ) : shaka.extern.AdCuePoint [] ;
    getStats ( ) : shaka.extern.AdsStats ;
    initClientSide (adContainer : any , video : any , adsRenderingSettings : any ) : any ;
    initServerSide (adContainer : any , video : any ) : any ;
    onAssetUnload ( ) : any ;
    onCueMetadataChange (value : any ) : any ;
    onDashTimedMetadata (region : any ) : any ;
    onHlsTimedMetadata (metadata : any , timestamp : any ) : any ;
    release ( ) : any ;
    replaceServerSideAdTagParameters (adTagParameters : any ) : any ;
    requestClientSideAds (imaRequest : any ) : any ;
    requestServerSideStream (imaRequest : google.ima.dai.api.StreamRequest , backupUrl ? : string ) : Promise < string > ;
    setLocale (locale : any ) : any ;
    updateClientSideAdsRenderingSettings (adsRenderingSettings : any ) : any ;
    /**
     * The event name for when a sequence of ads has been loaded.
     */
    static ADS_LOADED : string ;
    /**
     * The event name for when the client side SDK signalled its readiness
     * to play a VPAID ad or an ad rule.
     */
    static AD_BREAK_READY : string ;
    /**
     * The event name for when the ad is buffering.
     */
    static AD_BUFFERING : string ;
    /**
     * The event name for when the ad was clicked.
     */
    static AD_CLICKED : string ;
    /**
     * The event name for when the ad was closed by the user.
     */
    static AD_CLOSED : string ;
    /**
     * The event name for when an ad has completed playing.
     */
    static AD_COMPLETE : string ;
    /**
     * The event name for when the ad's duration changed.
     */
    static AD_DURATION_CHANGED : string ;
    /**
     * The event name for when the ad manager dispatch errors.
     */
    static AD_ERROR : string ;
    /**
     * The event name for when an ad playhead crosses first quartile.
     */
    static AD_FIRST_QUARTILE : string ;
    /**
     * The event name for when the ad's URL was hit.
     */
    static AD_IMPRESSION : string ;
    /**
     * The event name for when the interaction callback for the ad was
     * triggered.
     */
    static AD_INTERACTION : string ;
    /**
     * The event name for when the ad changes from or to linear.
     */
    static AD_LINEAR_CHANGED : string ;
    /**
     * The event name for when the ad data becomes available.
     */
    static AD_LOADED : string ;
    /**
     * The event name for when the ad's metadata becomes available.
     */
    static AD_METADATA : string ;
    /**
     * The event name for when an ad playhead crosses midpoint.
     */
    static AD_MIDPOINT : string ;
    /**
     * The event name for when the ad was muted.
     */
    static AD_MUTED : string ;
    /**
     * The event name for when the ad was paused.
     */
    static AD_PAUSED : string ;
    /**
     * The event name for when there is an update to the current ad's progress.
     */
    static AD_PROGRESS : string ;
    /**
     * The event name for when the ad display encountered a recoverable
     * error.
     */
    static AD_RECOVERABLE_ERROR : string ;
    /**
     * The event name for when the ad was resumed after a pause.
     */
    static AD_RESUMED : string ;
    /**
     * The event name for when an ad is skipped by the user..
     */
    static AD_SKIPPED : string ;
    /**
     * The event name for when the ad's skip status changes
     * (usually it becomes skippable when it wasn't before).
     */
    static AD_SKIP_STATE_CHANGED : string ;
    /**
     * The event name for when an ad has started playing.
     */
    static AD_STARTED : string ;
    /**
     * The event name for when an ad has finished playing
     * (played all the way through, was skipped, or was unable to proceed
     * due to an error).
     */
    static AD_STOPPED : string ;
    /**
     * The event name for when an ad playhead crosses third quartile.
     */
    static AD_THIRD_QUARTILE : string ;
    /**
     * The event name for when the ad volume has changed.
     */
    static AD_VOLUME_CHANGED : string ;
    /**
     * The event name for when all the ads were completed.
     */
    static ALL_ADS_COMPLETED : string ;
    /**
     * The event name for when the ad's cue points (start/end markers)
     * have changed.
     */
    static CUEPOINTS_CHANGED : string ;
    /**
     * The event name for when the native IMA ad manager object has
     * loaded and become available.
     */
    static IMA_AD_MANAGER_LOADED : string ;
    /**
     * The event name for when the native IMA stream manager object has
     * loaded and become available.
     */
    static IMA_STREAM_MANAGER_LOADED : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ads {
  class ClientSideAd implements shaka.extern.IAd {
    private noStructuralTyping_shaka_ads_ClientSideAd : any;
    constructor (imaAd : google.ima.Ad , imaAdManager : google.ima.AdsManager , video : HTMLMediaElement | null ) ;
    canSkipNow ( ) : any ;
    getAdId ( ) : any ;
    getAdvertiserName ( ) : any ;
    getCreativeAdId ( ) : any ;
    getDescription ( ) : any ;
    getDuration ( ) : any ;
    getMediaUrl ( ) : any ;
    getMinSuggestedDuration ( ) : any ;
    getPodIndex ( ) : any ;
    getPositionInSequence ( ) : any ;
    getRemainingTime ( ) : any ;
    getSequenceLength ( ) : any ;
    getTimeOffset ( ) : any ;
    getTimeUntilSkippable ( ) : any ;
    getTitle ( ) : any ;
    getVastMediaBitrate ( ) : any ;
    getVastMediaHeight ( ) : any ;
    getVastMediaWidth ( ) : any ;
    getVolume ( ) : any ;
    isLinear ( ) : any ;
    isMuted ( ) : any ;
    isPaused ( ) : any ;
    isSkippable ( ) : any ;
    pause ( ) : any ;
    play ( ) : any ;
    release ( ) : any ;
    resize (width : any , height : any ) : any ;
    setMuted (muted : any ) : any ;
    setVolume (volume : any ) : any ;
    skip ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ads {
  class ServerSideAd implements shaka.extern.IAd {
    private noStructuralTyping_shaka_ads_ServerSideAd : any;
    constructor (imaAd : google.ima.dai.api.Ad | null , video : HTMLMediaElement | null ) ;
    canSkipNow ( ) : any ;
    getAdId ( ) : any ;
    getAdvertiserName ( ) : any ;
    getCreativeAdId ( ) : any ;
    getDescription ( ) : any ;
    getDuration ( ) : any ;
    getMediaUrl ( ) : any ;
    getMinSuggestedDuration ( ) : any ;
    getPodIndex ( ) : any ;
    getPositionInSequence ( ) : any ;
    getRemainingTime ( ) : any ;
    getSequenceLength ( ) : any ;
    getTimeOffset ( ) : any ;
    getTimeUntilSkippable ( ) : any ;
    getTitle ( ) : any ;
    getVastMediaBitrate ( ) : any ;
    getVastMediaHeight ( ) : any ;
    getVastMediaWidth ( ) : any ;
    getVolume ( ) : any ;
    isLinear ( ) : any ;
    isMuted ( ) : any ;
    isPaused ( ) : any ;
    isSkippable ( ) : any ;
    pause ( ) : any ;
    play ( ) : any ;
    release ( ) : any ;
    resize (width : any , height : any ) : any ;
    setMuted (muted : any ) : any ;
    setVolume (volume : any ) : any ;
    skip ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.cast {
  class CastProxy extends shaka.util.FakeEventTarget implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_cast_CastProxy : any;
    constructor (video : HTMLMediaElement , player : shaka.Player , receiverAppId : string , androidReceiverCompatible : boolean ) ;
    canCast ( ) : boolean ;
    cast ( ) : Promise < any > ;
    changeReceiverId (newAppId : string , newCastAndroidReceiver ? : boolean ) : any ;
    /**
     * Destroys the proxy and the underlying local Player.
     * @param forceDisconnect If true, force the receiver app to shut down by disconnecting.  Does nothing if not connected.
     */
    destroy (forceDisconnect ? : boolean ) : Promise < any > ;
    /**
     * Force the receiver app to shut down by disconnecting.
     */
    forceDisconnect ( ) : any ;
    /**
     * Get a proxy for the Player that delegates to local and remote Player
     * objects as appropriate.
     */
    getPlayer ( ) : shaka.Player ;
    /**
     * Get a proxy for the video element that delegates to local and remote video
     * elements as appropriate.
     */
    getVideo ( ) : HTMLMediaElement ;
    isCasting ( ) : boolean ;
    receiverName ( ) : string ;
    /**
     * Set application-specific data.
     * @param appData Application-specific data to relay to the receiver.
     */
    setAppData (appData : object | null ) : any ;
    /**
     * Show a dialog where user can choose to disconnect from the cast connection.
     */
    suggestDisconnect ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.cast {
  /**
   * A receiver to communicate between the Chromecast-hosted player and the
   * sender application.
   */
  class CastReceiver extends shaka.util.FakeEventTarget implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_cast_CastReceiver : any;
    /**
     * A receiver to communicate between the Chromecast-hosted player and the
     * sender application.
     */
    constructor (video : HTMLMediaElement , player : shaka.Player , appDataCallback ? : (a : object | null ) => any , contentIdCallback ? : (a : string ) => string ) ;
    /**
     * Clear all Cast content metadata.
     * Should be called from an appDataCallback.
     */
    clearContentMetadata ( ) : any ;
    /**
     * Destroys the underlying Player, then terminates the cast receiver app.
     */
    destroy ( ) : Promise < any > ;
    isConnected ( ) : boolean ;
    isIdle ( ) : boolean ;
    /**
     * Set the Cast content's artist.
     * Also sets the metadata type to music.
     * Should be called from an appDataCallback.
     */
    setContentArtist (artist : string ) : any ;
    /**
     * Set the Cast content's thumbnail image.
     * Should be called from an appDataCallback.
     */
    setContentImage (imageUrl : string ) : any ;
    /**
     * Set all Cast content metadata, as defined by the Cast SDK.
     * Should be called from an appDataCallback.
     * For a simpler way to set basic metadata, see:
     * - setContentTitle()
     * - setContentImage()
     * - setContentArtist()
     * @param metadata A Cast metadata object, one of: - https://developers.google.com/cast/docs/reference/messages#GenericMediaMetadata - https://developers.google.com/cast/docs/reference/messages#MovieMediaMetadata - https://developers.google.com/cast/docs/reference/messages#TvShowMediaMetadata - https://developers.google.com/cast/docs/reference/messages#MusicTrackMediaMetadata
     */
    setContentMetadata (metadata : object | null ) : any ;
    /**
     * Set the Cast content's title.
     * Should be called from an appDataCallback.
     */
    setContentTitle (title : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.cea {
  /**
   * CEA-X08 captions decoder.
   */
  class CeaDecoder implements shaka.extern.ICaptionDecoder {
    private noStructuralTyping_shaka_cea_CeaDecoder : any;
    clear ( ) : any ;
    decode ( ) : shaka.extern.ICaptionDecoder.ClosedCaption [] ;
    extract (userDataSeiMessage : Uint8Array , pts : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.cea {
  /**
   * MPEG4 stream parser used for extracting 708 closed captions data.
   */
  class Mp4CeaParser implements shaka.extern.ICeaParser {
    private noStructuralTyping_shaka_cea_Mp4CeaParser : any;
    init (initSegment : ArrayBuffer | ArrayBufferView ) : any ;
    parse (mediaSegment : ArrayBuffer | ArrayBufferView ) : shaka.extern.ICeaParser.CaptionPacket [] ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.cea {
  /**
   * MPEG TS CEA parser.
   */
  class TsCeaParser implements shaka.extern.ICeaParser {
    private noStructuralTyping_shaka_cea_TsCeaParser : any;
    init (initSegment : ArrayBuffer | ArrayBufferView ) : any ;
    parse (mediaSegment : ArrayBuffer | ArrayBufferView ) : shaka.extern.ICeaParser.CaptionPacket [] ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.config {
  enum AutoShowText {
    ALWAYS = 1.0 ,
    IF_PREFERRED_TEXT_LANGUAGE = 2.0 ,
    IF_SUBTITLES_MAY_BE_NEEDED = 3.0 ,
    NEVER = 0.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.dash {
  /**
   * Creates a new DASH parser.
   */
  class DashParser implements shaka.extern.ManifestParser {
    private noStructuralTyping_shaka_dash_DashParser : any;
    configure (config : any ) : any ;
    onExpirationUpdated (sessionId : any , expiration : any ) : any ;
    start (uri : any , playerInterface : any ) : any ;
    stop ( ) : any ;
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka {
  class dependencies {
    private noStructuralTyping_shaka_dependencies : any;
    /**
     * Registers a new dependency.
     * @param key which is used for retrieving a dependency
     * @param dep a dependency
     */
    static add (key : shaka.dependencies.Allowed , dep : any ) : any ;
    /**
     * Check if we have a dependency for the key.
     * @param key key
     */
    static has (key : shaka.dependencies.Allowed ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.dependencies {
  enum Allowed {
    ISOBoxer = 'ISOBoxer' ,
    muxjs = 'muxjs' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.hls {
  /**
   * HLS parser.
   */
  class HlsParser implements shaka.extern.ManifestParser {
    private noStructuralTyping_shaka_hls_HlsParser : any;
    configure (config : any ) : any ;
    onExpirationUpdated (sessionId : any , expiration : any ) : any ;
    start (uri : any , playerInterface : any ) : any ;
    stop ( ) : any ;
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.lcevc {
  class Dil implements shaka.util.IReleasable {
    private noStructuralTyping_shaka_lcevc_Dil : any;
    constructor (media : HTMLVideoElement | null , canvas : HTMLCanvasElement | null , dilConfig : shaka.extern.LcevcConfiguration ) ;
    /**
     * Close LCEVC Dil.
     */
    release ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * Closed Caption Parser provides all operations for parsing the closed captions
   * embedded in Dash videos streams.
   */
  class ClosedCaptionParser implements shaka.media.IClosedCaptionParser {
    private noStructuralTyping_shaka_media_ClosedCaptionParser : any;
    /**
     * Closed Caption Parser provides all operations for parsing the closed captions
     * embedded in Dash videos streams.
     */
    constructor (mimeType : string ) ;
    static findDecoder ( ) : ( shaka.extern.CaptionDecoderPlugin ) | null ;
    static findParser (mimeType : string ) : ( shaka.extern.CeaParserPlugin ) | null ;
    static registerDecoder (plugin : shaka.extern.CaptionDecoderPlugin ) : any ;
    static registerParser (mimeType : string , plugin : shaka.extern.CeaParserPlugin ) : any ;
    static unregisterDecoder ( ) : any ;
    static unregisterParser (mimeType : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * The IClosedCaptionParser defines the interface to provide all operations for
   * parsing the closed captions embedded in Dash videos streams.
   * TODO: Remove this interface and move method definitions
   * directly to ClosedCaptonParser.
   */
  interface IClosedCaptionParser {
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * Creates an InitSegmentReference, which provides the location to an
   * initialization segment.
   */
  class InitSegmentReference {
    private noStructuralTyping_shaka_media_InitSegmentReference : any;
    constructor (uris : ( ) => string [] , startByte : number , endByte : number | null , mediaQuality ? : null | shaka.extern.MediaQualityInfo , timescale ? : null | number , segmentData ? : null | ArrayBuffer | ArrayBufferView ) ;
    /**
     * Returns the offset from the start of the resource to the end of the
     * segment, inclusive.  A value of null indicates that the segment extends
     * to the end of the resource.
     */
    getEndByte ( ) : number | null ;
    /**
     * Returns the offset from the start of the resource to the
     * start of the segment.
     */
    getStartByte ( ) : number ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  class ManifestParser {
    private noStructuralTyping_shaka_media_ManifestParser : any;
    /**
     * Registers a manifest parser by file extension.
     * @param extension The file extension of the manifest.
     * @param parserFactory The factory used to create parser instances.
     */
    static registerParserByExtension (extension : string , parserFactory : shaka.extern.ManifestParser.Factory ) : any ;
    /**
     * Registers a manifest parser by MIME type.
     * @param mimeType The MIME type of the manifest.
     * @param parserFactory The factory used to create parser instances.
     */
    static registerParserByMime (mimeType : string , parserFactory : shaka.extern.ManifestParser.Factory ) : any ;
    /**
     * Unregisters a manifest parser by MIME type.
     * @param mimeType The MIME type of the manifest.
     */
    static unregisterParserByMime (mimeType : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media.ManifestParser {
  enum AccessibilityPurpose {
    HARD_OF_HEARING = 'hard of hearing' ,
    VISUALLY_IMPAIRED = 'visually impaired' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * A meta-SegmentIndex composed of multiple other SegmentIndexes.
   * Used in constructing multi-Period Streams for DASH.
   */
  class MetaSegmentIndex extends shaka.media.SegmentIndex implements Iterable < shaka.media.SegmentReference > {
    private noStructuralTyping_shaka_media_MetaSegmentIndex : any;
    /**
     * A meta-SegmentIndex composed of multiple other SegmentIndexes.
     * Used in constructing multi-Period Streams for DASH.
     */
    constructor ( ) ;
    //!! Symbol.iterator inserted by Clutz for Iterable subtype
    [Symbol.iterator]():  Iterator < shaka.media.SegmentReference > ;
    evict (time : number ) : any ;
    find (time : number ) : number | null ;
    fit (windowStart : number , windowEnd : number | null , c ? : boolean ) : any ;
    get (position : number ) : shaka.media.SegmentReference | null ;
    merge (references : any ) : any ;
    mergeAndEvict (references : shaka.media.SegmentReference [] , windowStart : number ) : any ;
    offset (offset : number ) : any ;
    release ( ) : any ;
    updateEvery (interval : number , updateCallback : ( ) => ( shaka.media.SegmentReference | null ) [] | null ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * PresentationTimeline.
   */
  class PresentationTimeline {
    private noStructuralTyping_shaka_media_PresentationTimeline : any;
    constructor (presentationStartTime : number | null , presentationDelay : number , autoCorrectDrift ? : boolean ) ;
    /**
     * Gets the presentation delay in seconds.
     */
    getDelay ( ) : number ;
    getDuration ( ) : number ;
    getMaxSegmentDuration ( ) : number ;
    getPresentationStartTime ( ) : number | null ;
    /**
     * Gets the seek range start time, offset by the given amount.  This is used
     * to ensure that we don't "fall" back out of the seek window while we are
     * buffering.
     * @param offset The offset to add to the start time for live streams.
     */
    getSafeSeekRangeStart (offset : number ) : number ;
    /**
     * Gets the seek range end.
     */
    getSeekRangeEnd ( ) : number ;
    /**
     * Gets the seek range start time.
     */
    getSeekRangeStart ( ) : number ;
    /**
     * Gets the presentation's current segment availability end time.  Segments
     * starting after this time should be assumed to be unavailable.
     */
    getSegmentAvailabilityEnd ( ) : number ;
    /**
     * Gets the presentation's current segment availability start time.  Segments
     * ending at or before this time should be assumed to be unavailable.
     */
    getSegmentAvailabilityStart ( ) : number ;
    isInProgress ( ) : boolean ;
    isLive ( ) : boolean ;
    /**
     * Lock the presentation timeline's start time.  After this is called, no
     * further adjustments to presentationStartTime_ will be permitted.
     * This should be called after all Periods have been parsed, and all calls to
     * notifySegments() from the initial manifest parse have been made.
     * Without this, we can get assertion failures in SegmentIndex for certain
     * DAI content.  If DAI adds ad segments to the manifest faster than
     * real-time, adjustments to presentationStartTime_ can cause availability
     * windows to jump around on updates.
     */
    lockStartTime ( ) : any ;
    /**
     * Gives PresentationTimeline a Stream's maximum segment duration so it can
     * size and position the segment availability window.  This function should be
     * called once for each Stream (no more, no less), but does not have to be
     * called if notifySegments() is called instead for a particular stream.
     * @param maxSegmentDuration The maximum segment duration for a particular stream.
     */
    notifyMaxSegmentDuration (maxSegmentDuration : number ) : any ;
    /**
     * Gives PresentationTimeline a Stream's minimum segment start time.
     */
    notifyMinSegmentStartTime (startTime : number ) : any ;
    /**
     * Gives PresentationTimeline an array of segments so it can size and position
     * the segment availability window, and account for missing segment
     * information.  These segments do not necessarily need to all be from the
     * same stream.
     */
    notifySegments (references : shaka.media.SegmentReference [] ) : any ;
    /**
     * Gives PresentationTimeline a Stream's timeline so it can size and position
     * the segment availability window, and account for missing segment
     * information.
     */
    notifyTimeRange (timeline : shaka.media.PresentationTimeline.TimeRange [] , startOffset : number ) : any ;
    /**
     * Offsets the segment times by the given amount.
     * @param offset The number of seconds to offset by.  A positive number adjusts the segment times forward.
     */
    offset (offset : number ) : any ;
    /**
     * Sets the presentation's segment availability time offset. This should be
     * only set for Low Latency Dash.
     * The segments are available earlier for download than the availability start
     * time, so we can move closer to the live edge.
     */
    setAvailabilityTimeOffset (offset : number ) : any ;
    /**
     * Sets the clock offset, which is the difference between the client's clock
     * and the server's clock, in milliseconds (i.e., serverTime = Date.now() +
     * clockOffset).
     * @param offset The clock offset, in ms.
     */
    setClockOffset (offset : number ) : any ;
    /**
     * Sets the presentation delay in seconds.
     */
    setDelay (delay : number ) : any ;
    /**
     * Sets the presentation's duration.
     * @param duration The presentation's duration in seconds. Infinity indicates that the presentation continues indefinitely.
     */
    setDuration (duration : number ) : any ;
    /**
     * Sets the presentation's start time.
     * @param presentationStartTime The wall-clock time, in seconds, when the presentation started or will start. Only required for live.
     */
    setPresentationStartTime (presentationStartTime : number ) : any ;
    /**
     * Sets the presentation's segment availability duration. The segment
     * availability duration should only be set for live.
     * @param segmentAvailabilityDuration The presentation's new segment availability duration in seconds.
     */
    setSegmentAvailabilityDuration (segmentAvailabilityDuration : number ) : any ;
    /**
     * Sets the presentation's static flag.
     * @param isStatic If true, the presentation is static, meaning all segments are available at once.
     */
    setStatic (isStatic : boolean ) : any ;
    /**
     * Sets the start time of the user-defined seek range.  This is only used for
     * VOD content.
     */
    setUserSeekStart (time : number ) : any ;
    /**
     * True if the presentation start time is being used to calculate the live
     * edge.
     * Using the presentation start time means that the stream may be subject to
     * encoder drift.  At runtime, we will avoid using the presentation start time
     * whenever possible.
     */
    usingPresentationStartTime ( ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media.PresentationTimeline {
  type TimeRange = { end : number , start : number , unscaledStart : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * SegmentIndex.
   */
  class SegmentIndex implements Iterable < shaka.media.SegmentReference > {
    private noStructuralTyping_shaka_media_SegmentIndex : any;
    /**
     * SegmentIndex.
     */
    constructor (references : shaka.media.SegmentReference [] ) ;
    //!! Symbol.iterator inserted by Clutz for Iterable subtype
    [Symbol.iterator]():  Iterator < shaka.media.SegmentReference > ;
    /**
     * Removes all SegmentReferences that end before the given time.
     * @param time The time in seconds.
     */
    evict (time : number ) : any ;
    /**
     * Finds the position of the segment for the given time, in seconds, relative
     * to the start of the presentation.  Returns the position of the segment
     * with the largest end time if more than one segment is known for the given
     * time.
     */
    find (time : number ) : number | null ;
    /**
     * Drops references that start after windowEnd, or end before windowStart,
     * and contracts the last reference so that it ends at windowEnd.
     * Do not call on the last period of a live presentation (unknown duration).
     * It is okay to call on the other periods of a live presentation, where the
     * duration is known and another period has been added.
     * @param isNew Whether this is a new SegmentIndex and we shouldn't update the number of evicted elements.
     */
    fit (windowStart : number , windowEnd : number | null , isNew ? : boolean ) : any ;
    /**
     * Gets the SegmentReference for the segment at the given position.
     * @param position The position of the segment as returned by find().
     */
    get (position : number ) : shaka.media.SegmentReference | null ;
    /**
     * Returns a new iterator that initially points to the segment that contains
     * the given time, or the nearest independent segment before it.
     * Like the normal iterator, next() must be called first to get to the first
     * element. Returns null if we do not find a segment at the
     * requested time.
     * The first segment returned by the iterator _MUST_ be an independent
     * segment.  Assumes that only partial references can be dependent, based on
     * RFC 8216 rev 13, section 8.1: "Each (non-Partial) Media Segment in a Media
     * Playlist will contain at least one independent frame."
     */
    getIteratorForTime (time : number ) : shaka.media.SegmentIterator | null ;
    /**
     * Marks the index as immutable.  Segments cannot be added or removed after
     * this point.  This doesn't affect the references themselves.  This also
     * makes the destroy/release methods do nothing.
     * This is mainly for testing.
     */
    markImmutable ( ) : any ;
    /**
     * Merges the given SegmentReferences and evicts the ones that end before the
     * given time.  Supports extending the original references only.
     * Will not replace old references or interleave new ones.
     * Used, for example, by the DASH and HLS parser, where manifests may not list
     * all available references, so we must keep available references in memory to
     * fill the availability window.
     * @param references The list of SegmentReferences, which must be sorted first by their start times (ascending) and second by their end times (ascending).
     * @param windowStart The start of the availability window to filter out the references that are no longer available.
     */
    mergeAndEvict (references : shaka.media.SegmentReference [] , windowStart : number ) : any ;
    /**
     * Offset all segment references by a fixed amount.
     * @param offset The amount to add to each segment's start and end times.
     */
    offset (offset : number ) : any ;
    release ( ) : any ;
    /**
     * Updates the references every so often.  Stops when the references list
     * returned by the callback is null.
     * @param interval The interval in seconds.
     */
    updateEvery (interval : number , updateCallback : ( ) => ( shaka.media.SegmentReference | null ) [] | null ) : any ;
    /**
     * Create a SegmentIndex for a single segment of the given start time and
     * duration at the given URIs.
     */
    static forSingleSegment (startTime : number , duration : number , uris : string [] ) : shaka.media.SegmentIndex ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * An iterator over a SegmentIndex's references.
   */
  class SegmentIterator implements Iterator < shaka.media.SegmentReference | null > {
    private noStructuralTyping_shaka_media_SegmentIterator : any;
    /**
     * An iterator over a SegmentIndex's references.
     */
    constructor (segmentIndex : shaka.media.SegmentIndex | null , index : number , partialSegmentIndex : number ) ;
    current ( ) : shaka.media.SegmentReference | null ;
    currentPosition ( ) : number ;
    next ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media.SegmentPrefetch {
  type FetchDispatcher = (a : shaka.media.InitSegmentReference | shaka.media.SegmentReference , b : shaka.extern.Stream , c ? : ( (a : ArrayBuffer | ArrayBufferView ) => Promise < any > ) | null ) => shaka.net.NetworkingEngine.PendingRequest ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media {
  /**
   * SegmentReference provides the start time, end time, and location to a media
   * segment.
   */
  class SegmentReference {
    private noStructuralTyping_shaka_media_SegmentReference : any;
    constructor (startTime : number , endTime : number , uris : ( ) => string [] , startByte : number , endByte : number | null , initSegmentReference : shaka.media.InitSegmentReference | null , timestampOffset : number , appendWindowStart : number , appendWindowEnd : number , partialReferences ? : shaka.media.SegmentReference [] , tilesLayout ? : string | null , tileDuration ? : number | null , syncTime ? : number | null , status ? : shaka.media.SegmentReference.Status , hlsAes128Key ? : shaka.extern.HlsAes128Key | null ) ;
    /**
     * Returns the offset from the start of the resource to the end of the
     * segment, inclusive.  A value of null indicates that the segment extends to
     * the end of the resource.
     */
    getEndByte ( ) : number | null ;
    /**
     * Returns the segment's end time in seconds.
     */
    getEndTime ( ) : number ;
    /**
     * Returns the offset from the start of the resource to the
     * start of the segment.
     */
    getStartByte ( ) : number ;
    /**
     * Returns the segment's start time in seconds.
     */
    getStartTime ( ) : number ;
    /**
     * Returns the segment's status.
     */
    getStatus ( ) : shaka.media.SegmentReference.Status ;
    /**
     * Returns the segment's thumbnail sprite.
     */
    getThumbnailSprite ( ) : shaka.media.SegmentReference.ThumbnailSprite | null ;
    /**
     * Returns the segment's explicit tile duration.
     * Only defined in image segments.
     */
    getTileDuration ( ) : number | null ;
    /**
     * Returns the segment's tiles layout. Only defined in image segments.
     */
    getTilesLayout ( ) : string | null ;
    /**
     * Creates and returns the URIs of the resource containing the segment.
     */
    getUris ( ) : string [] ;
    /**
     * Returns true if the segment has a byterange optimization.
     */
    hasByterangeOptimization ( ) : boolean ;
    /**
     * Returns true if the segment is independent.
     */
    isIndependent ( ) : boolean ;
    /**
     * Returns true if the segment is preloaded.
     */
    isPreload ( ) : boolean ;
    /**
     * Mark the reference as byterange optimization.
     * The "byterange optimization" means that it is playable using MP4 low
     * latency streaming with chunked data.
     */
    markAsByterangeOptimization ( ) : any ;
    /**
     * Mark the reference as non-independent.
     */
    markAsNonIndependent ( ) : any ;
    /**
     * Mark the reference as preload.
     */
    markAsPreload ( ) : any ;
    /**
     * Mark the reference as unavailable.
     */
    markAsUnavailable ( ) : any ;
    /**
     * Offset the segment reference by a fixed amount.
     * @param offset The amount to add to the segment's start and end times.
     */
    offset (offset : number ) : any ;
    /**
     * Set the segment's thumbnail sprite.
     */
    setThumbnailSprite (thumbnailSprite : shaka.media.SegmentReference.ThumbnailSprite ) : any ;
    /**
     * Sync this segment against a particular sync time that will serve as "0" in
     * the presentation timeline.
     */
    syncAgainst (lowestSyncTime : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media.SegmentReference {
  /**
   * Rather than using booleans to communicate what the state of the reference,
   * we have this enum.
   */
  /**
   * Rather than using booleans to communicate what the state of the reference,
   * we have this enum.
   */
  enum Status {
    AVAILABLE = 0.0 ,
    MISSING = 2.0 ,
    UNAVAILABLE = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.media.SegmentReference {
  type ThumbnailSprite = { height : number , positionX : number , positionY : number , width : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.mss {
  /**
   * Creates a new MSS parser.
   */
  class MssParser implements shaka.extern.ManifestParser {
    private noStructuralTyping_shaka_mss_MssParser : any;
    configure (config : any ) : any ;
    onExpirationUpdated (sessionId : any , expiration : any ) : any ;
    start (uri : any , playerInterface : any ) : any ;
    stop ( ) : any ;
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net {
  class DataUriPlugin {
    private noStructuralTyping_shaka_net_DataUriPlugin : any;
    static parse (uri : string , request : shaka.extern.Request , requestType : shaka.net.NetworkingEngine.RequestType , progressUpdated : shaka.extern.ProgressUpdated ) : shaka.extern.IAbortableOperation < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net {
  class HttpFetchPlugin {
    private noStructuralTyping_shaka_net_HttpFetchPlugin : any;
    /**
     * Determine if the Fetch API is supported in the browser. Note: this is
     * deliberately exposed as a method to allow the client app to use the same
     * logic as Shaka when determining support.
     */
    static isSupported ( ) : boolean ;
    static parse (uri : string , request : shaka.extern.Request , requestType : shaka.net.NetworkingEngine.RequestType , progressUpdated : shaka.extern.ProgressUpdated , headersReceived : shaka.extern.HeadersReceived ) : shaka.extern.IAbortableOperation < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net {
  class HttpXHRPlugin {
    private noStructuralTyping_shaka_net_HttpXHRPlugin : any;
    static parse (uri : string , request : shaka.extern.Request , requestType : shaka.net.NetworkingEngine.RequestType , progressUpdated : shaka.extern.ProgressUpdated , headersReceived : shaka.extern.HeadersReceived ) : shaka.extern.IAbortableOperation < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net {
  /**
   * NetworkingEngine wraps all networking operations.  This accepts plugins that
   * handle the actual request.  A plugin is registered using registerScheme.
   * Each scheme has at most one plugin to handle the request.
   */
  class NetworkingEngine extends shaka.util.FakeEventTarget implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_net_NetworkingEngine : any;
    /**
     * NetworkingEngine wraps all networking operations.  This accepts plugins that
     * handle the actual request.  A plugin is registered using registerScheme.
     * Each scheme has at most one plugin to handle the request.
     */
    constructor (onProgressUpdated ? : (a : number , b : number ) => any , onHeadersReceived ? : shaka.net.NetworkingEngine.OnHeadersReceived , onDownloadFailed ? : shaka.net.NetworkingEngine.OnDownloadFailed , onRequest ? : shaka.net.NetworkingEngine.OnRequest ) ;
    /**
     * Clears all request filters.
     */
    clearAllRequestFilters ( ) : any ;
    /**
     * Clears all response filters.
     */
    clearAllResponseFilters ( ) : any ;
    destroy ( ) : Promise < any > ;
    /**
     * Registers a new request filter.  All filters are applied in the order they
     * are registered.
     */
    registerRequestFilter (filter : shaka.extern.RequestFilter ) : any ;
    /**
     * Registers a new response filter.  All filters are applied in the order they
     * are registered.
     */
    registerResponseFilter (filter : shaka.extern.ResponseFilter ) : any ;
    /**
     * Makes a network request and returns the resulting data.
     */
    request (type : shaka.net.NetworkingEngine.RequestType , request : shaka.extern.Request , context ? : shaka.extern.RequestContext ) : shaka.net.NetworkingEngine.PendingRequest ;
    setForceHTTPS (forceHTTPS : boolean ) : any ;
    /**
     * Removes a request filter.
     */
    unregisterRequestFilter (filter : shaka.extern.RequestFilter ) : any ;
    /**
     * Removes a response filter.
     */
    unregisterResponseFilter (filter : shaka.extern.ResponseFilter ) : any ;
    /**
     * Gets a copy of the default retry parameters.
     */
    static defaultRetryParameters ( ) : shaka.extern.RetryParameters ;
    /**
     * Makes a simple network request for the given URIs.
     */
    static makeRequest (uris : string [] , retryParams : shaka.extern.RetryParameters , streamDataCallback ? : ( (a : ArrayBuffer | ArrayBufferView ) => Promise < any > ) | null ) : shaka.extern.Request ;
    /**
     * Registers a scheme plugin.  This plugin will handle all requests with the
     * given scheme.  If a plugin with the same scheme already exists, it is
     * replaced, unless the existing plugin is of higher priority.
     * If no priority is provided, this defaults to the highest priority of
     * APPLICATION.
     */
    static registerScheme (scheme : string , plugin : shaka.extern.SchemePlugin , priority ? : number , progressSupport ? : boolean ) : any ;
    /**
     * Removes a scheme plugin.
     */
    static unregisterScheme (scheme : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  /**
   * A more advanced form of the RequestType structure, meant to describe
   * sub-types of basic request types.
   * For example, an INIT_SEGMENT is a sub-type of SEGMENT.
   * This is meant to allow for more specificity to be added to the request type
   * data, without breaking backwards compatibility.
   */
  /**
   * A more advanced form of the RequestType structure, meant to describe
   * sub-types of basic request types.
   * For example, an INIT_SEGMENT is a sub-type of SEGMENT.
   * This is meant to allow for more specificity to be added to the request type
   * data, without breaking backwards compatibility.
   */
  enum AdvancedRequestType {
    INIT_SEGMENT = 0.0 ,
    MASTER_PLAYLIST = 3.0 ,
    MEDIA_PLAYLIST = 2.0 ,
    MEDIA_SEGMENT = 1.0 ,
    MPD = 4.0 ,
    MSS = 5.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  /**
   * A wrapper class for the number of bytes remaining to be downloaded for the
   * request.
   * Instead of using PendingRequest directly, this class is needed to be sent to
   * plugin as a parameter, and a Promise is returned, before PendingRequest is
   * created.
   */
  class NumBytesRemainingClass {
    private noStructuralTyping_shaka_net_NetworkingEngine_NumBytesRemainingClass : any;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  type OnDownloadFailed = (a : shaka.extern.Request , b : shaka.util.Error | null , c : number , d : boolean ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  type OnHeadersReceived = (a : { [ key: string ]: string } , b : shaka.extern.Request , c : shaka.net.NetworkingEngine.RequestType ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  type OnRequest = (a : shaka.net.NetworkingEngine.RequestType , b : shaka.extern.Request , c : shaka.extern.RequestContext | undefined ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  /**
   * A pending network request. This can track the current progress of the
   * download, and allows the request to be aborted if the network is slow.
   */
  class PendingRequest extends shaka.util.AbortableOperation < any > implements shaka.extern.IAbortableOperation < any > {
    private noStructuralTyping_shaka_net_NetworkingEngine_PendingRequest : any;
    /**
     * A pending network request. This can track the current progress of the
     * download, and allows the request to be aborted if the network is slow.
     */
    constructor (promise : Promise < any > , onAbort : shaka.extern.CreateSegmentIndexFunction , numBytesRemainingObj : shaka.net.NetworkingEngine.NumBytesRemainingClass | null ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  /**
   * Priority level for network scheme plugins.
   * If multiple plugins are provided for the same scheme, only the
   * highest-priority one is used.
   */
  /**
   * Priority level for network scheme plugins.
   * If multiple plugins are provided for the same scheme, only the
   * highest-priority one is used.
   */
  enum PluginPriority {
    APPLICATION = 3.0 ,
    FALLBACK = 1.0 ,
    PREFERRED = 2.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.net.NetworkingEngine {
  /**
   * Request types.  Allows a filter to decide which requests to read/alter.
   */
  /**
   * Request types.  Allows a filter to decide which requests to read/alter.
   */
  enum RequestType {
    APP = 3.0 ,
    KEY = 6.0 ,
    LICENSE = 2.0 ,
    MANIFEST = 0.0 ,
    SEGMENT = 1.0 ,
    SERVER_CERTIFICATE = 5.0 ,
    TIMING = 4.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.offline {
  class OfflineScheme {
    private noStructuralTyping_shaka_offline_OfflineScheme : any;
    static plugin (uri : string , request : shaka.extern.Request , requestType : shaka.net.NetworkingEngine.RequestType , progressUpdated : shaka.extern.ProgressUpdated ) : shaka.extern.IAbortableOperation < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.offline {
  class Storage implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_offline_Storage : any;
    constructor (player ? : shaka.Player ) ;
    /**
     * Sets configuration values for Storage.  This is associated with
     * Player.configure and will change the player instance given at
     * initialization.
     * @param config This should either be a field name or an object following the form of {@link shaka.extern.PlayerConfiguration}, where you may omit any field you do not wish to change.
     * @param value This should be provided if the previous parameter was a string field name.
     */
    configure (config : string | object , value ? : any ) : boolean ;
    destroy ( ) : Promise < any > ;
    /**
     * Return a copy of the current configuration.  Modifications of the returned
     * value will not affect the Storage instance's active configuration.  You
     * must call storage.configure() to make changes.
     */
    getConfiguration ( ) : shaka.extern.PlayerConfiguration ;
    /**
     * Return the networking engine that storage is using. If storage was
     * initialized with a player instance, then the networking engine returned
     * will be the same as |player.getNetworkingEngine()|.
     * The returned value will only be null if |destroy| was called before
     * |getNetworkingEngine|.
     */
    getNetworkingEngine ( ) : shaka.net.NetworkingEngine | null ;
    /**
     * Lists all the stored content available.
     */
    list ( ) : Promise < shaka.extern.StoredContent [] > ;
    /**
     * Removes the given stored content.  This will also attempt to release the
     * licenses, if any.
     */
    remove (contentUri : string ) : Promise < any > ;
    /**
     * Removes any EME sessions that were not successfully removed before.  This
     * returns whether all the sessions were successfully removed.
     */
    removeEmeSessions ( ) : Promise < boolean > ;
    /**
     * Stores the given manifest.  If the content is encrypted, and encrypted
     * content cannot be stored on this platform, the Promise will be rejected
     * with error code 6001, REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE.
     * Multiple assets can be downloaded at the same time, but note that since
     * the storage instance has a single networking engine, multiple storage
     * objects will be necessary if some assets require unique network filters.
     * This snapshots the storage config at the time of the call, so it will not
     * honor any changes to config mid-store operation.
     * @param uri The URI of the manifest to store.
     * @param appMetadata An arbitrary object from the application that will be stored along-side the offline content.  Use this for any application-specific metadata you need associated with the stored content.  For details on the data types that can be stored here, please refer to {@link https://bit.ly/StructClone}
     * @param mimeType The mime type for the content |manifestUri| points to.
     */
    store (uri : string , appMetadata ? : object , mimeType ? : string ) : shaka.extern.IAbortableOperation < any > ;
    /**
     * Delete the on-disk storage and all the content it contains. This should not
     * be done in normal circumstances. Only do it when storage is rendered
     * unusable, such as by a version mismatch. No business logic will be run, and
     * licenses will not be released.
     */
    static deleteAll ( ) : Promise < any > ;
    /**
     * Gets whether offline storage is supported.  Returns true if offline storage
     * is supported for clear content.  Support for offline storage of encrypted
     * content will not be determined until storage is attempted.
     */
    static support ( ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.offline {
  /**
   * StorageMuxer is responsible for managing StorageMechanisms and addressing
   * cells. The primary purpose of the muxer is to give the caller the correct
   * cell for the operations they want to perform.
   * |findActive| will be used when the caller wants a cell that supports
   * add-operations. This will be used when saving new content to storage.
   * |findAll| will be used when the caller want to look at all the content
   * in storage.
   * |resolvePath| will be used to convert a path (from |findActive| and
   * |findAll|) into a cell, which it then returns.
   */
  class StorageMuxer implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_offline_StorageMuxer : any;
    /**
     * Free all resources used by the muxer, mechanisms, and cells. This should
     * not affect the stored content.
     */
    destroy ( ) : Promise < any > ;
    /**
     * Register a storage mechanism for use with the default storage muxer. This
     * will have no effect on any storage muxer already in main memory.
     */
    static register (name : string , factory : ( ) => shaka.extern.StorageMechanism | null ) : any ;
    /**
     * Unregister a storage mechanism for use with the default storage muxer. This
     * will have no effect on any storage muxer already in main memory.
     * @param name The name that the storage mechanism was registered under.
     */
    static unregister (name : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka {
  class polyfill {
    private noStructuralTyping_shaka_polyfill : any;
    /**
     * Install all polyfills.
     */
    static installAll ( ) : any ;
    /**
     * Registers a new polyfill to be installed.
     * @param priority An optional number priority.  Higher priorities will be executed before lower priority ones.  Default is 0.
     */
    static register (polyfill : ( ) => any , priority ? : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class AbortController extends AbortController {
    private noStructuralTyping_shaka_polyfill_AbortController : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class Aria {
    private noStructuralTyping_shaka_polyfill_Aria : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class EncryptionScheme {
    private noStructuralTyping_shaka_polyfill_EncryptionScheme : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class Fullscreen {
    private noStructuralTyping_shaka_polyfill_Fullscreen : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class MediaCapabilities {
    private noStructuralTyping_shaka_polyfill_MediaCapabilities : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
    /**
     * A copy of the MediaCapabilities instance, to prevent Safari from
     * garbage-collecting the polyfilled method on it. We make it public and export
     * it to ensure that it is not stripped out by the compiler.
     */
    static originalMcap : any | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class MediaSource {
    private noStructuralTyping_shaka_polyfill_MediaSource : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class Orientation {
    private noStructuralTyping_shaka_polyfill_Orientation : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class PatchedMediaKeysApple {
    private noStructuralTyping_shaka_polyfill_PatchedMediaKeysApple : any;
    /**
     * Installs the polyfill if needed.
     * @param enableUninstall enables uninstalling the polyfill
     */
    static install (enableUninstall ? : boolean ) : any ;
    /**
     * Uninstalls the polyfill if needed and enabled.
     */
    static uninstall ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class PatchedMediaKeysNop {
    private noStructuralTyping_shaka_polyfill_PatchedMediaKeysNop : any;
    /**
     * Installs the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class PatchedMediaKeysWebkit {
    private noStructuralTyping_shaka_polyfill_PatchedMediaKeysWebkit : any;
    /**
     * Installs the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class PiPWebkit {
    private noStructuralTyping_shaka_polyfill_PiPWebkit : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class RandomUUID {
    private noStructuralTyping_shaka_polyfill_RandomUUID : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class StorageEstimate {
    private noStructuralTyping_shaka_polyfill_StorageEstimate : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class Symbol {
    private noStructuralTyping_shaka_polyfill_Symbol : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class VTTCue {
    private noStructuralTyping_shaka_polyfill_VTTCue : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class VideoPlayPromise {
    private noStructuralTyping_shaka_polyfill_VideoPlayPromise : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.polyfill {
  class VideoPlaybackQuality {
    private noStructuralTyping_shaka_polyfill_VideoPlaybackQuality : any;
    /**
     * Install the polyfill if needed.
     */
    static install ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class Cue {
    private noStructuralTyping_shaka_text_Cue : any;
    constructor (startTime : number , endTime : number , payload : string ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  /**
   * Default text background color according to
   * https://w3c.github.io/webvtt/#default-text-background
   */
  /**
   * Default text background color according to
   * https://w3c.github.io/webvtt/#default-text-background
   */
  enum defaultTextBackgroundColor {
    bg_black = 'black' ,
    bg_blue = 'blue' ,
    bg_cyan = 'cyan' ,
    bg_lime = 'lime' ,
    bg_magenta = 'magenta' ,
    bg_red = 'red' ,
    bg_white = 'white' ,
    bg_yellow = 'yellow' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  /**
   * Default text color according to
   * https://w3c.github.io/webvtt/#default-text-color
   */
  /**
   * Default text color according to
   * https://w3c.github.io/webvtt/#default-text-color
   */
  enum defaultTextColor {
    black = 'black' ,
    blue = 'blue' ,
    cyan = 'cyan' ,
    lime = 'lime' ,
    magenta = 'magenta' ,
    red = 'red' ,
    white = 'white' ,
    yellow = 'yellow' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum direction {
    HORIZONTAL_LEFT_TO_RIGHT = 'ltr' ,
    HORIZONTAL_RIGHT_TO_LEFT = 'rtl' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  /**
   * Vertical alignments of the cues within their extents.
   * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'
   * means in the middle, 'AFTER' means at the bottom.
   */
  /**
   * Vertical alignments of the cues within their extents.
   * 'BEFORE' means displaying at the top of the captions container box, 'CENTER'
   * means in the middle, 'AFTER' means at the bottom.
   */
  enum displayAlign {
    AFTER = 'after' ,
    BEFORE = 'before' ,
    CENTER = 'center' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum fontStyle {
    ITALIC = 'italic' ,
    NORMAL = 'normal' ,
    OBLIQUE = 'oblique' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  /**
   * In CSS font weight can be a number, where 400 is normal and 700 is bold.
   * Use these values for the enum for consistency.
   */
  /**
   * In CSS font weight can be a number, where 400 is normal and 700 is bold.
   * Use these values for the enum for consistency.
   */
  enum fontWeight {
    BOLD = 700.0 ,
    NORMAL = 400.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum lineAlign {
    CENTER = 'center' ,
    END = 'end' ,
    START = 'start' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum lineInterpretation {
    LINE_NUMBER = 0.0 ,
    PERCENTAGE = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum positionAlign {
    AUTO = 'auto' ,
    CENTER = 'center' ,
    LEFT = 'line-left' ,
    RIGHT = 'line-right' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum textAlign {
    CENTER = 'center' ,
    END = 'end' ,
    LEFT = 'left' ,
    RIGHT = 'right' ,
    START = 'start' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum textDecoration {
    LINE_THROUGH = 'lineThrough' ,
    OVERLINE = 'overline' ,
    UNDERLINE = 'underline' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.Cue {
  enum writingMode {
    HORIZONTAL_TOP_TO_BOTTOM = 'horizontal-tb' ,
    VERTICAL_LEFT_TO_RIGHT = 'vertical-lr' ,
    VERTICAL_RIGHT_TO_LEFT = 'vertical-rl' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class CueRegion {
    private noStructuralTyping_shaka_text_CueRegion : any;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.CueRegion {
  enum scrollMode {
    NONE = '' ,
    UP = 'up' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text.CueRegion {
  enum units {
    LINES = 2.0 ,
    PERCENTAGE = 1.0 ,
    PX = 0.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  /**
   * LRC file format: https://en.wikipedia.org/wiki/LRC_(file_format)
   */
  class LrcTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_LrcTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class Mp4TtmlParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_Mp4TtmlParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class Mp4VttParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_Mp4VttParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class SbvTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_SbvTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  /**
   * A text displayer plugin using the browser's native VTTCue interface.
   */
  class SimpleTextDisplayer implements shaka.extern.TextDisplayer {
    private noStructuralTyping_shaka_text_SimpleTextDisplayer : any;
    /**
     * A text displayer plugin using the browser's native VTTCue interface.
     */
    constructor (video : HTMLMediaElement | null ) ;
    append (cues : any ) : any ;
    destroy ( ) : any ;
    isTextVisible ( ) : any ;
    remove (start : any , end : any ) : any ;
    setTextVisibility (on : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class SrtTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_SrtTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
    /**
     * Convert a SRT format to WebVTT
     */
    static srt2webvtt (data : string ) : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  /**
   * Documentation: http://moodub.free.fr/video/ass-specs.doc
   * https://en.wikipedia.org/wiki/SubStation_Alpha
   */
  class SsaTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_SsaTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class TextEngine implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_text_TextEngine : any;
    constructor (displayer : shaka.extern.TextDisplayer | null ) ;
    destroy ( ) : Promise < any > ;
    static findParser (mimeType : any ) : ( shaka.extern.TextParserPlugin ) | null ;
    static registerParser (mimeType : string , plugin : shaka.extern.TextParserPlugin ) : any ;
    static unregisterParser (mimeType : string ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class TtmlTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_TtmlTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  /**
   * The text displayer plugin for the Shaka Player UI.  Can also be used directly
   * by providing an appropriate container element.
   */
  class UITextDisplayer implements shaka.extern.TextDisplayer {
    private noStructuralTyping_shaka_text_UITextDisplayer : any;
    /**
     * The text displayer plugin for the Shaka Player UI.  Can also be used directly
     * by providing an appropriate container element.
     */
    constructor (video : HTMLMediaElement | null , videoContainer : HTMLElement | null ) ;
    append (cues : any ) : any ;
    destroy ( ) : any ;
    isTextVisible ( ) : any ;
    remove (start : any , end : any ) : any ;
    setTextVisibility (on : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class VttTextParser implements shaka.extern.TextParser {
    private noStructuralTyping_shaka_text_VttTextParser : any;
    parseInit (data : any ) : any ;
    parseMedia (data : any , time : any ) : any ;
    setSequenceMode (sequenceMode : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.text {
  class WebVttGenerator {
    private noStructuralTyping_shaka_text_WebVttGenerator : any;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class AacTransmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_AacTransmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any , duration : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class Ac3Transmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_Ac3Transmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any , duration : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class Ec3Transmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_Ec3Transmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any , duration : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class Mp3Transmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_Mp3Transmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any , duration : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class MpegTsTransmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_MpegTsTransmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class MssTransmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_MssTransmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class MuxjsTransmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_MuxjsTransmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class TransmuxerEngine implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_transmuxer_TransmuxerEngine : any;
    destroy ( ) : Promise < any > ;
    static findTransmuxer (mimeType : string , contentType ? : string ) : ( shaka.extern.TransmuxerPlugin ) | null ;
    static registerTransmuxer (mimeType : string , plugin : shaka.extern.TransmuxerPlugin , priority : number ) : any ;
    static unregisterTransmuxer (mimeType : string , priority : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer.TransmuxerEngine {
  /**
   * Priority level for transmuxer plugins.
   * If multiple plugins are provided for the same mime type, only the
   * highest-priority one is used.
   */
  /**
   * Priority level for transmuxer plugins.
   * If multiple plugins are provided for the same mime type, only the
   * highest-priority one is used.
   */
  enum PluginPriority {
    APPLICATION = 4.0 ,
    FALLBACK = 1.0 ,
    PREFERRED = 3.0 ,
    PREFERRED_SECONDARY = 2.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.transmuxer {
  class TsTransmuxer implements shaka.extern.Transmuxer {
    private noStructuralTyping_shaka_transmuxer_TsTransmuxer : any;
    constructor (mimeType : string ) ;
    convertCodecs (contentType : any , mimeType : any ) : any ;
    destroy ( ) : any ;
    getOrginalMimeType ( ) : any ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    transmux (data : any , stream : any , reference : any , duration : any , contentType : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class AdCounter extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_AdCounter : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class AdPosition extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_AdPosition : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class AirPlayButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_AirPlayButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class AudioLanguageSelection extends shaka.ui.SettingsMenu {
    private noStructuralTyping_shaka_ui_AudioLanguageSelection : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class BigPlayButton extends shaka.ui.PlayButton {
    private noStructuralTyping_shaka_ui_BigPlayButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class CastButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_CastButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class ContextMenu extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_ContextMenu : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
    static registerElement (name : string , factory : shaka.extern.IUIElement.Factory ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  /**
   * A container for custom video controls.
   */
  class Controls extends shaka.util.FakeEventTarget implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_ui_Controls : any;
    /**
     * A container for custom video controls.
     */
    constructor (player : shaka.Player , videoContainer : HTMLElement , video : HTMLMediaElement , config : shaka.extern.UIConfiguration ) ;
    /**
     * This allows the application to inhibit casting.
     */
    allowCast (allow : boolean ) : any ;
    anySettingsMenusAreOpen ( ) : boolean ;
    configure (config : shaka.extern.UIConfiguration ) : any ;
    destroy ( ) : Promise < any > ;
    getAd ( ) : shaka.extern.IAd | null ;
    getCastProxy ( ) : shaka.cast.CastProxy | null ;
    getClientSideAdContainer ( ) : HTMLElement ;
    getConfig ( ) : shaka.extern.UIConfiguration ;
    getControlsContainer ( ) : HTMLElement ;
    getDisplayTime ( ) : number ;
    getLocalPlayer ( ) : shaka.Player | null ;
    getLocalVideo ( ) : HTMLMediaElement | null ;
    getLocalization ( ) : shaka.ui.Localization | null ;
    getPlayer ( ) : shaka.Player | null ;
    getServerSideAdContainer ( ) : HTMLElement ;
    getVideo ( ) : HTMLMediaElement | null ;
    getVideoContainer ( ) : HTMLElement ;
    hideAdUI ( ) : any ;
    hideSettingsMenus ( ) : any ;
    isCastAllowed ( ) : boolean ;
    isFullScreenEnabled ( ) : boolean ;
    isFullScreenSupported ( ) : boolean ;
    isOpaque ( ) : boolean ;
    isSeeking ( ) : boolean ;
    /**
     * Used by the application to notify the controls that a load operation is
     * complete.  This allows the controls to recalculate play/paused state, which
     * is important for platforms like Android where autoplay is disabled.
     */
    loadComplete ( ) : any ;
    /**
     * Enable or disable native browser controls. Enabling disables shaka
     * controls.
     */
    setEnabledNativeControls (enabled : boolean ) : any ;
    /**
     * Enable or disable the custom controls. Enabling disables native
     * browser controls.
     */
    setEnabledShakaControls (enabled : boolean ) : any ;
    setLastTouchEventTime (time : number | null ) : any ;
    setSeeking (seeking : boolean ) : any ;
    showAdUI ( ) : any ;
    toggleFullScreen ( ) : any ;
    static registerElement (name : string , factory : shaka.extern.IUIElement.Factory ) : any ;
    static registerSeekBar (factory : shaka.extern.IUISeekBar.Factory ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  abstract class Element implements shaka.extern.IUIElement {
    private noStructuralTyping_shaka_ui_Element : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
ad : shaka.extern.IAd | null ;
adManager : shaka.extern.IAdManager | null ;
controls : shaka.ui.Controls | null ;
eventManager : shaka.util.EventManager | null ;
localization : shaka.ui.Localization | null ;
parent : HTMLElement | null ;
player : shaka.Player | null ;
    release ( ) : any ;
video : HTMLMediaElement | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class FastForwardButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_FastForwardButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class FullscreenButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_FullscreenButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  /**
   * Localization system provided by the shaka ui library.
   * It can be used to store the various localized forms of
   * strings that are expected to be displayed to the user.
   * If a string is not available, it will return the localized
   * form in the closest related locale.
   */
  class Localization extends shaka.util.FakeEventTarget {
    private noStructuralTyping_shaka_ui_Localization : any;
    constructor (fallbackLocale : string ) ;
    /**
     * Request the localization system to change which locale it serves. If any of
     * of the preferred locales cannot be found, the localization system will fire
     * an event identifying which locales it does not know. The localization
     * system will then continue to operate using the closest matches it has.
     * @param locales The locale codes for the requested locales in order of preference.
     */
    changeLocale (locales : Iterable < string > ) : any ;
    /**
     * Insert a set of localizations for a single locale. This will amend the
     * existing localizations for the given locale.
     * @param locale The locale that the localizations should be added to.
     * @param localizations A mapping of id to localized text that should used to modify the internal collection of localizations.
     * @param conflictResolution The strategy used to resolve conflicts when the id of an existing entry matches the id of a new entry. Default to |USE_NEW|, where the new entry will replace the old entry.
     */
    insert (locale : string , localizations : Map < string , string > , conflictResolution ? : shaka.ui.Localization.ConflictResolution ) : shaka.ui.Localization ;
    release ( ) : any ;
    /**
     * Request the localized string under the given id. If there is no localized
     * version of the string, then the fallback localization will be given
     * ("en" version). If there is no fallback localization, a non-null empty
     * string will be returned.
     * @param id The id for the localization entry.
     */
    resolve (id : string ) : string ;
    /**
     * Set the value under each key in |dictionary| to the resolved value.
     * Convenient for apps with some kind of data binding system.
     * Equivalent to:
     * for (const key of dictionary.keys()) {
     * dictionary.set(key, localization.resolve(key));
     * }
     */
    resolveDictionary (dictionary : Map < string , string > ) : any ;
    /**
     * The event name for when a new locale has been requested and any previously
     * resolved values should be updated.
     */
    static LOCALE_CHANGED : string ;
    /**
     * The event name for when |insert| was called and it changed entries that could
     * affect previously resolved values.
     */
    static LOCALE_UPDATED : string ;
    /**
     * The event name for when entries are missing from the user's preferred
     * locale, but we were able to find an entry in a related locale or the fallback
     * locale.
     */
    static MISSING_LOCALIZATIONS : string ;
    /**
     * The event name for when locales were requested, but we could not find any
     * entries for them. The localization system will continue to use the closest
     * matches it has.
     */
    static UNKNOWN_LOCALES : string ;
    /**
     * The event name for when an entry could not be found in the preferred locale,
     * related locales, or the fallback locale.
     */
    static UNKNOWN_LOCALIZATION : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui.Localization {
  /**
   * An enum for how the localization system should resolve conflicts between old
   * translations and new translations.
   */
  /**
   * An enum for how the localization system should resolve conflicts between old
   * translations and new translations.
   */
  enum ConflictResolution {
    USE_NEW = 1.0 ,
    USE_OLD = 0.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class LoopButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_LoopButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class MuteButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_MuteButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class OverflowMenu extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_OverflowMenu : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
    static registerElement (name : string , factory : shaka.extern.IUIElement.Factory ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class Overlay implements shaka.util.IDestroyable {
    private noStructuralTyping_shaka_ui_Overlay : any;
    constructor (player : shaka.Player , videoContainer : HTMLElement , video : HTMLMediaElement ) ;
    configure (config : string | object , value ? : any ) : any ;
    destroy ( ) : Promise < any > ;
    getConfiguration ( ) : shaka.extern.UIConfiguration ;
    getControls ( ) : shaka.ui.Controls | null ;
    /**
     * Detects if this is a mobile platform, in case you want to choose a
     * different UI configuration on mobile devices.
     */
    isMobile ( ) : boolean ;
    /**
     * Enable or disable the custom controls.
     */
    setEnabled (enabled : boolean ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui.Overlay {
  /**
   * Describes the possible reasons that the UI might fail to load.
   */
  /**
   * Describes the possible reasons that the UI might fail to load.
   */
  enum FailReasonCode {
    NO_BROWSER_SUPPORT = 0.0 ,
    PLAYER_FAILED_TO_LOAD = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui.Overlay {
  /**
   * Describes what information should show up in labels for selecting audio
   * variants and text tracks.
   */
  /**
   * Describes what information should show up in labels for selecting audio
   * variants and text tracks.
   */
  enum TrackLabelFormat {
    LABEL = 3.0 ,
    LANGUAGE = 0.0 ,
    LANGUAGE_ROLE = 2.0 ,
    ROLE = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class PipButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_PipButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class PlayButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_PlayButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class PlaybackRateSelection extends shaka.ui.SettingsMenu {
    private noStructuralTyping_shaka_ui_PlaybackRateSelection : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class PresentationTimeTracker extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_PresentationTimeTracker : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  /**
   * A range element, built to work across browsers.
   * In particular, getting styles to work right on IE requires a specific
   * structure.
   * This also handles the case where the range element is being manipulated and
   * updated at the same time.  This can happen when seeking during playback or
   * when casting.
   */
  class RangeElement extends shaka.ui.Element implements shaka.extern.IUIRangeElement {
    private noStructuralTyping_shaka_ui_RangeElement : any;
    /**
     * A range element, built to work across browsers.
     * In particular, getting styles to work right on IE requires a specific
     * structure.
     * This also handles the case where the range element is being manipulated and
     * updated at the same time.  This can happen when seeking during playback or
     * when casting.
     */
    constructor (parent : HTMLElement , controls : shaka.ui.Controls , containerClassNames : string [] , barClassNames : string [] ) ;
    bar : HTMLInputElement ;
    /**
     * Called to implement keyboard-based changes, where this is no clear "end".
     * This will simulate events like onChangeStart(), onChange(), and
     * onChangeEnd() as appropriate.
     */
    changeTo (value : any ) : any ;
    container : HTMLElement ;
    getValue ( ) : any ;
    /**
     * Called when a new value is set by user interaction.
     * To be overridden by subclasses.
     */
    onChange ( ) : any ;
    /**
     * Called when user interaction ends.
     * To be overridden by subclasses.
     */
    onChangeEnd ( ) : any ;
    /**
     * Called when user interaction begins.
     * To be overridden by subclasses.
     */
    onChangeStart ( ) : any ;
    setRange (min : any , max : any ) : any ;
    setValue (value : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class ResolutionSelection extends shaka.ui.SettingsMenu {
    private noStructuralTyping_shaka_ui_ResolutionSelection : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class RewindButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_RewindButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class SeekBar extends shaka.ui.RangeElement implements shaka.extern.IUISeekBar {
    private noStructuralTyping_shaka_ui_SeekBar : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
    isShowing ( ) : boolean ;
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui.SeekBar {
  class Factory implements shaka.extern.IUISeekBar.Factory {
    private noStructuralTyping_shaka_ui_SeekBar_Factory : any;
    create (rootElement : HTMLElement , controls : shaka.ui.Controls ) : shaka.extern.IUISeekBar ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class SettingsMenu extends shaka.ui.Element implements shaka.extern.IUISettingsMenu {
    private noStructuralTyping_shaka_ui_SettingsMenu : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls , iconText : string ) ;
    backButton : HTMLButtonElement ;
    backSpan : HTMLElement ;
    button : HTMLButtonElement ;
    currentSelection : HTMLElement ;
    icon : HTMLElement ;
    menu : HTMLElement ;
    nameSpan : HTMLElement ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class SkipAdButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_SkipAdButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class SmallPlayButton extends shaka.ui.PlayButton {
    private noStructuralTyping_shaka_ui_SmallPlayButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class Spacer extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_Spacer : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class StatisticsButton extends shaka.ui.Element {
    private noStructuralTyping_shaka_ui_StatisticsButton : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class TextSelection extends shaka.ui.SettingsMenu {
    private noStructuralTyping_shaka_ui_TextSelection : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.ui {
  class VolumeBar extends shaka.ui.RangeElement {
    private noStructuralTyping_shaka_ui_VolumeBar : any;
    constructor (parent : HTMLElement , controls : shaka.ui.Controls ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  /**
   * A utility to wrap abortable operations.  Note that these are not cancelable.
   * Cancelation implies undoing what has been done so far, whereas aborting only
   * means that further work is stopped.
   */
  class AbortableOperation < T > implements shaka.extern.IAbortableOperation < T > {
    private noStructuralTyping_shaka_util_AbortableOperation : any;
    /**
     * A utility to wrap abortable operations.  Note that these are not cancelable.
     * Cancelation implies undoing what has been done so far, whereas aborting only
     * means that further work is stopped.
     */
    constructor (promise : Promise < T > , onAbort : shaka.extern.CreateSegmentIndexFunction ) ;
    abort ( ) : any ;
    chain < U > (onSuccess : undefined | Function , onError ? : (a : any ) => any ) : shaka.util.AbortableOperation < U > ;
    finally (onFinal : any ) : any ;
    promise : Promise < T > ;
    static aborted ( ) : shaka.util.AbortableOperation < any > ;
    static all (operations : shaka.util.AbortableOperation < any > [] ) : shaka.util.AbortableOperation < any > ;
    static completed < U > (value : U ) : shaka.util.AbortableOperation < U > ;
    static failed (error : shaka.util.Error ) : shaka.util.AbortableOperation < any > ;
    static notAbortable < U > (promise : Promise < U > ) : shaka.util.AbortableOperation < U > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class BufferUtils {
    private noStructuralTyping_shaka_util_BufferUtils : any;
    /**
     * Compare two buffers for equality.  For buffers of different types, this
     * compares the underlying buffers as binary data.
     */
    static equal (arr1 : ArrayBuffer | ArrayBufferView | null , arr2 : ArrayBuffer | ArrayBufferView | null ) : boolean ;
    /**
     * Gets an ArrayBuffer that contains the data from the given TypedArray.  Note
     * this will allocate a new ArrayBuffer if the object is a partial view of
     * the data.
     */
    static toArrayBuffer (view : ArrayBuffer | ArrayBufferView ) : ArrayBuffer ;
    /**
     * Creates a DataView over the given buffer.
     */
    static toDataView (buffer : ArrayBuffer | ArrayBufferView , offset ? : number , length ? : number ) : DataView ;
    /**
     * Creates a new Uint8Array view on the same buffer.  This clamps the values
     * to be within the same view (i.e. you can't use this to move past the end
     * of the view, even if the underlying buffer is larger).  However, you can
     * pass a negative offset to access the data before the view.
     * @param offset The offset from the beginning of this data's view to start the new view at.
     * @param length The byte length of the new view.
     */
    static toUint8 (data : ArrayBuffer | ArrayBufferView , offset ? : number , length ? : number ) : Uint8Array ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.CmcdManager {
  enum StreamingFormat {
    DASH = 'd' ,
    HLS = 'h' ,
    OTHER = 'o' ,
    SMOOTH = 's' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class ConfigUtils {
    private noStructuralTyping_shaka_util_ConfigUtils : any;
    /**
     * Convert config from ('fieldName', value) format to a partial config object.
     * E. g. from ('manifest.retryParameters.maxAttempts', 1) to
     * { manifest: { retryParameters: { maxAttempts: 1 }}}.
     */
    static convertToConfigObject (fieldName : string , value : any ) : object ;
    static mergeConfigObjects (destination : object , source : object , template : object , overrides : object , path : string ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class DataViewReader {
    private noStructuralTyping_shaka_util_DataViewReader : any;
    constructor (data : ArrayBuffer | ArrayBufferView , endianness : shaka.util.DataViewReader.Endianness ) ;
    /**
     * Gets the byte length of the DataView.
     */
    getLength ( ) : number ;
    /**
     * Gets the current byte position.
     */
    getPosition ( ) : number ;
    hasMoreData ( ) : boolean ;
    /**
     * Reads the specified number of raw bytes.
     * @param bytes The number of bytes to read.
     */
    readBytes (bytes : number ) : Uint8Array ;
    /**
     * Reads a signed 32 bit integer, and advances the reader.
     */
    readInt32 ( ) : number ;
    /**
     * Keeps reading until it reaches a byte that equals to zero.  The text is
     * assumed to be UTF-8.
     */
    readTerminatedString ( ) : string ;
    /**
     * Reads an unsigned 16 bit integer, and advances the reader.
     */
    readUint16 ( ) : number ;
    /**
     * Reads an unsigned 32 bit integer, and advances the reader.
     */
    readUint32 ( ) : number ;
    /**
     * Reads an unsigned 64 bit integer, and advances the reader.
     */
    readUint64 ( ) : number ;
    /**
     * Reads an unsigned 8 bit integer, and advances the reader.
     */
    readUint8 ( ) : number ;
    /**
     * Rewinds the specified number of bytes.
     * @param bytes The number of bytes to rewind.
     */
    rewind (bytes : number ) : any ;
    /**
     * Seeks to a specified position.
     * @param position The desired byte position within the DataView.
     */
    seek (position : number ) : any ;
    /**
     * Skips the specified number of bytes.
     * @param bytes The number of bytes to skip.
     */
    skip (bytes : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.DataViewReader {
  /**
   * Endianness.
   */
  /**
   * Endianness.
   */
  enum Endianness {
    BIG_ENDIAN = 0.0 ,
    LITTLE_ENDIAN = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class Dom {
    private noStructuralTyping_shaka_util_Dom : any;
    /**
     * Remove all of the child nodes of an element.
     */
    static removeAllChildren (element : Element ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class Error extends GlobalError implements shaka.extern.Error {
    private noStructuralTyping_shaka_util_Error : any;
    constructor (severity : shaka.util.Error.Severity , category : shaka.util.Error.Category , code : shaka.util.Error.Code ,  ...varArgs : any [] ) ;
    category : any ;
    code : any ;
    data : any ;
    handled : any ;
    severity : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.Error {
  enum Category {
    ADS = 10.0 ,
    CAST = 8.0 ,
    DRM = 6.0 ,
    MANIFEST = 4.0 ,
    MEDIA = 3.0 ,
    NETWORK = 1.0 ,
    PLAYER = 7.0 ,
    STORAGE = 9.0 ,
    STREAMING = 5.0 ,
    TEXT = 2.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.Error {
  enum Code {
    ALREADY_CASTING = 8002.0 ,
    ATTEMPTS_EXHAUSTED = 1010.0 ,
    BAD_ENCODING = 2004.0 ,
    BAD_HTTP_STATUS = 1001.0 ,
    BUFFER_READ_OUT_OF_BOUNDS = 3000.0 ,
    CANNOT_ADD_EXTERNAL_TEXT_TO_LIVE_STREAM = 4033.0 ,
    CANNOT_ADD_EXTERNAL_TEXT_TO_SRC_EQUALS = 2012.0 ,
    CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_LIVE_STREAM = 4045.0 ,
    CANNOT_ADD_EXTERNAL_THUMBNAILS_TO_SRC_EQUALS = 2016.0 ,
    CANNOT_STORE_LIVE_OFFLINE = 9005.0 ,
    CAST_API_UNAVAILABLE = 8000.0 ,
    CAST_CANCELED_BY_USER = 8004.0 ,
    CAST_CONNECTION_TIMED_OUT = 8005.0 ,
    CAST_RECEIVER_APP_UNAVAILABLE = 8006.0 ,
    CHAPTERS_TRACK_FAILED = 2015.0 ,
    CONTENT_NOT_LOADED = 7004.0 ,
    CONTENT_TRANSFORMATION_FAILED = 3019.0 ,
    CONTENT_UNSUPPORTED_BY_BROWSER = 4032.0 ,
    CS_AD_MANAGER_NOT_INITIALIZED = 10001.0 ,
    CS_IMA_SDK_MISSING = 10000.0 ,
    CURRENT_DAI_REQUEST_NOT_FINISHED = 10004.0 ,
    DASH_CONFLICTING_KEY_IDS = 4010.0 ,
    DASH_DUPLICATE_REPRESENTATION_ID = 4018.0 ,
    DASH_EMPTY_ADAPTATION_SET = 4003.0 ,
    DASH_EMPTY_PERIOD = 4004.0 ,
    DASH_INVALID_XML = 4001.0 ,
    DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED = 4009.0 ,
    DASH_NO_COMMON_KEY_SYSTEM = 4008.0 ,
    DASH_NO_SEGMENT_INFO = 4002.0 ,
    DASH_PSSH_BAD_ENCODING = 4007.0 ,
    DASH_UNSUPPORTED_CONTAINER = 4006.0 ,
    DASH_UNSUPPORTED_XLINK_ACTUATE = 4027.0 ,
    DASH_WEBM_MISSING_INIT = 4005.0 ,
    DASH_XLINK_DEPTH_LIMIT = 4028.0 ,
    DEPRECATED_OPERATION_ABORTED = 9002.0 ,
    DOWNLOAD_SIZE_CALLBACK_ERROR = 9015.0 ,
    EBML_BAD_FLOATING_POINT_SIZE = 3003.0 ,
    EBML_OVERFLOW = 3002.0 ,
    ENCRYPTED_CONTENT_WITHOUT_DRM_INFO = 6010.0 ,
    ERROR_CHECKING_HDCP_VERSION = 6019.0 ,
    EXPIRED = 6014.0 ,
    FAILED_TO_ATTACH_TO_VIDEO = 6003.0 ,
    FAILED_TO_CREATE_CDM = 6002.0 ,
    FAILED_TO_CREATE_SESSION = 6005.0 ,
    FAILED_TO_GENERATE_LICENSE_REQUEST = 6006.0 ,
    HLS_AES_128_INVALID_IV_LENGTH = 4043.0 ,
    HLS_AES_128_INVALID_KEY_LENGTH = 4044.0 ,
    HLS_COULD_NOT_GUESS_CODECS = 4025.0 ,
    HLS_INVALID_PLAYLIST_HIERARCHY = 4017.0 ,
    HLS_KEYFORMATS_NOT_SUPPORTED = 4026.0 ,
    HLS_MSE_ENCRYPTED_LEGACY_APPLE_MEDIA_KEYS_NOT_SUPPORTED = 4041.0 ,
    HLS_MSE_ENCRYPTED_MP2T_NOT_SUPPORTED = 4040.0 ,
    HLS_MULTIPLE_MEDIA_INIT_SECTIONS_FOUND = 4020.0 ,
    HLS_PLAYLIST_HEADER_MISSING = 4015.0 ,
    HLS_REQUIRED_ATTRIBUTE_MISSING = 4023.0 ,
    HLS_REQUIRED_TAG_MISSING = 4024.0 ,
    HLS_VARIABLE_NOT_FOUND = 4039.0 ,
    HTTP_ERROR = 1002.0 ,
    INCONSISTENT_DRM_ACROSS_PERIODS = 4038.0 ,
    INDEXED_DB_ERROR = 9001.0 ,
    INDEXED_DB_INIT_TIMED_OUT = 9017.0 ,
    INIT_DATA_TRANSFORM_ERROR = 6016.0 ,
    INVALID_HLS_TAG = 4016.0 ,
    INVALID_MP4_CEA = 2010.0 ,
    INVALID_MP4_TTML = 2007.0 ,
    INVALID_MP4_VTT = 2008.0 ,
    INVALID_SERVER_CERTIFICATE = 6004.0 ,
    INVALID_TEXT_CUE = 2001.0 ,
    INVALID_TEXT_HEADER = 2000.0 ,
    INVALID_XML = 2005.0 ,
    JS_INTEGER_OVERFLOW = 3001.0 ,
    KEY_NOT_FOUND = 9012.0 ,
    LICENSE_REQUEST_FAILED = 6007.0 ,
    LICENSE_RESPONSE_REJECTED = 6008.0 ,
    LOAD_INTERRUPTED = 7000.0 ,
    LOCAL_PLAYER_INSTANCE_REQUIRED = 9008.0 ,
    MALFORMED_DATA_URI = 1004.0 ,
    MALFORMED_OFFLINE_URI = 9004.0 ,
    MALFORMED_TEST_URI = 1008.0 ,
    MEDIA_SOURCE_OPERATION_FAILED = 3014.0 ,
    MEDIA_SOURCE_OPERATION_THREW = 3015.0 ,
    MIN_HDCP_VERSION_NOT_MATCH = 6018.0 ,
    MISSING_STORAGE_CELL = 9013.0 ,
    MISSING_TEXT_PLUGIN = 2014.0 ,
    MODIFY_OPERATION_NOT_SUPPORTED = 9016.0 ,
    MP4_SIDX_INVALID_TIMESCALE = 3005.0 ,
    MP4_SIDX_TYPE_NOT_SUPPORTED = 3006.0 ,
    MP4_SIDX_WRONG_BOX_TYPE = 3004.0 ,
    MSS_INVALID_XML = 4046.0 ,
    MSS_LIVE_CONTENT_NOT_SUPPORTED = 4047.0 ,
    MSS_MISSING_DATA_FOR_TRANSMUXING = 3020.0 ,
    MSS_TRANSMUXING_CODEC_UNKNOWN = 3021.0 ,
    MSS_TRANSMUXING_FAILED = 3022.0 ,
    NEW_KEY_OPERATION_NOT_SUPPORTED = 9011.0 ,
    NO_CAST_RECEIVERS = 8001.0 ,
    NO_INIT_DATA_FOR_OFFLINE = 9007.0 ,
    NO_LICENSE_SERVER_GIVEN = 6012.0 ,
    NO_RECOGNIZED_KEY_SYSTEMS = 6000.0 ,
    NO_VARIANTS = 4036.0 ,
    NO_VIDEO_ELEMENT = 7002.0 ,
    NO_WEB_CRYPTO_API = 4042.0 ,
    OBJECT_DESTROYED = 7003.0 ,
    OFFLINE_SESSION_REMOVED = 6013.0 ,
    OPERATION_ABORTED = 7001.0 ,
    PERIOD_FLATTENING_FAILED = 4037.0 ,
    QUOTA_EXCEEDED_ERROR = 3017.0 ,
    REQUESTED_ITEM_NOT_FOUND = 9003.0 ,
    REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE = 6001.0 ,
    REQUEST_FILTER_ERROR = 1006.0 ,
    RESPONSE_FILTER_ERROR = 1007.0 ,
    RESTRICTIONS_CANNOT_BE_MET = 4012.0 ,
    SEGMENT_MISSING = 1011.0 ,
    SERVER_CERTIFICATE_REQUEST_FAILED = 6017.0 ,
    SERVER_CERTIFICATE_REQUIRED = 6015.0 ,
    SS_AD_MANAGER_NOT_INITIALIZED = 10003.0 ,
    SS_IMA_SDK_MISSING = 10002.0 ,
    STORAGE_LIMIT_REACHED = 9014.0 ,
    STORAGE_NOT_SUPPORTED = 9000.0 ,
    STREAMING_ENGINE_STARTUP_INVALID_STATE = 5006.0 ,
    TEXT_COULD_NOT_GUESS_MIME_TYPE = 2011.0 ,
    TEXT_ONLY_WEBVTT_SRC_EQUALS = 2013.0 ,
    TIMEOUT = 1003.0 ,
    TRANSMUXING_FAILED = 3018.0 ,
    UNABLE_TO_DETECT_ENCODING = 2003.0 ,
    UNABLE_TO_EXTRACT_CUE_START_TIME = 2009.0 ,
    UNABLE_TO_GUESS_MANIFEST_TYPE = 4000.0 ,
    UNEXPECTED_CAST_ERROR = 8003.0 ,
    UNEXPECTED_TEST_REQUEST = 1009.0 ,
    UNSUPPORTED_EXTERNAL_THUMBNAILS_URI = 2017.0 ,
    UNSUPPORTED_SCHEME = 1000.0 ,
    VIDEO_ERROR = 3016.0 ,
    WEBM_CUES_ELEMENT_MISSING = 3007.0 ,
    WEBM_CUE_TIME_ELEMENT_MISSING = 3013.0 ,
    WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING = 3012.0 ,
    WEBM_DURATION_ELEMENT_MISSING = 3011.0 ,
    WEBM_EBML_HEADER_ELEMENT_MISSING = 3008.0 ,
    WEBM_INFO_ELEMENT_MISSING = 3010.0 ,
    WEBM_SEGMENT_ELEMENT_MISSING = 3009.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.Error {
  enum Severity {
    CRITICAL = 2.0 ,
    RECOVERABLE = 1.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class EventManager implements shaka.util.IReleasable {
    private noStructuralTyping_shaka_util_EventManager : any;
    /**
     * Attaches an event listener to an event target.
     * @param target The event target.
     * @param type The event type.
     * @param listener The event listener.
     * @param options An object that specifies characteristics about the event listener. The passive option, if true, indicates that this function will never call preventDefault(), which improves scrolling performance.
     */
    listen (target : EventTarget | null , type : string , listener : shaka.util.EventManager.ListenerType , options ? : boolean | AddEventListenerOptions ) : any ;
    /**
     * Attaches an event listener to an event target.  The listener will be
     * removed when the first instance of the event is fired.
     * @param target The event target.
     * @param type The event type.
     * @param listener The event listener.
     * @param options An object that specifies characteristics about the event listener. The passive option, if true, indicates that this function will never call preventDefault(), which improves scrolling performance.
     */
    listenOnce (target : EventTarget | null , type : string , listener : shaka.util.EventManager.ListenerType , options ? : boolean | AddEventListenerOptions ) : any ;
    /**
     * Detaches all event listeners.
     */
    release ( ) : any ;
    /**
     * Detaches all event listeners from all targets.
     */
    removeAll ( ) : any ;
    /**
     * Detaches an event listener from an event target.
     * @param target The event target.
     * @param type The event type.
     * @param listener The event listener.
     */
    unlisten (target : EventTarget | null , type : string , listener ? : shaka.util.EventManager.ListenerType ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.EventManager {
  type ListenerType = (a : Event ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class ExpGolomb {
    private noStructuralTyping_shaka_util_ExpGolomb : any;
    constructor (data : Uint8Array ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class FairPlayUtils {
    private noStructuralTyping_shaka_util_FairPlayUtils : any;
    /**
     * Common FairPlay response transform for some DRMs providers.
     */
    static commonFairPlayResponse (type : shaka.net.NetworkingEngine.RequestType , response : shaka.extern.Response , context ? : shaka.extern.RequestContext ) : any ;
    /**
     * Conax FairPlay request.
     */
    static conaxFairPlayRequest (type : shaka.net.NetworkingEngine.RequestType , request : shaka.extern.Request , context ? : shaka.extern.RequestContext ) : any ;
    /**
     * Conax initDataTransform configuration.
     */
    static conaxInitDataTransform (initData : Uint8Array , initDataType : string , drmInfo : shaka.extern.DrmInfo | null ) : any ;
    /**
     * Using the default method, extract a content ID from the init data.  This is
     * based on the FairPlay example documentation.
     */
    static defaultGetContentId (initData : ArrayBuffer | ArrayBufferView ) : string ;
    /**
     * ExpressPlay FairPlay request.
     */
    static expressplayFairPlayRequest (type : shaka.net.NetworkingEngine.RequestType , request : shaka.extern.Request , context ? : shaka.extern.RequestContext ) : any ;
    /**
     * ExpressPlay initDataTransform configuration.
     */
    static expressplayInitDataTransform (initData : Uint8Array , initDataType : string , drmInfo : shaka.extern.DrmInfo | null ) : any ;
    /**
     * EZDRM FairPlay request.
     */
    static ezdrmFairPlayRequest (type : shaka.net.NetworkingEngine.RequestType , request : shaka.extern.Request , context ? : shaka.extern.RequestContext ) : any ;
    /**
     * EZDRM initDataTransform configuration.
     */
    static ezdrmInitDataTransform (initData : Uint8Array , initDataType : string , drmInfo : shaka.extern.DrmInfo | null ) : any ;
    /**
     * Transforms the init data buffer using the given data.  The format is:
     * <pre>
     * [4 bytes] initDataSize
     * [initDataSize bytes] initData
     * [4 bytes] contentIdSize
     * [contentIdSize bytes] contentId
     * [4 bytes] certSize
     * [certSize bytes] cert
     * </pre>
     * @param cert The server certificate; this will throw if not provided.
     */
    static initDataTransform (initData : ArrayBuffer | ArrayBufferView , contentId : ArrayBuffer | ArrayBufferView | string , cert : ArrayBuffer | ArrayBufferView | null ) : Uint8Array ;
    /**
     * Check if FairPlay is supported.
     */
    static isFairPlaySupported ( ) : Promise < boolean > ;
    /**
     * Verimatrix FairPlay request.
     */
    static verimatrixFairPlayRequest (type : shaka.net.NetworkingEngine.RequestType , request : shaka.extern.Request , context ? : shaka.extern.RequestContext ) : any ;
    /**
     * Verimatrix initDataTransform configuration.
     */
    static verimatrixInitDataTransform (initData : Uint8Array , initDataType : string , drmInfo : shaka.extern.DrmInfo | null ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class FakeEvent extends Event {
    private noStructuralTyping_shaka_util_FakeEvent : any;
    constructor (type : string , dict ? : Map < string , object | null > | null ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class FakeEventTarget implements EventTarget , shaka.util.IReleasable {
    private noStructuralTyping_shaka_util_FakeEventTarget : any;
    /**
     * Add an event listener to this object.
     * @param type The event type to listen for.
     * @param listener The callback or listener object to invoke.
     * @param options Ignored.
     */
    addEventListener (type : string , listener : EventListener | null | ( (a : Event ) => any ) , options ? : AddEventListenerOptions | boolean ) : any ;
    /**
     * Dispatch an event from this object.
     * @param event The event to be dispatched from this object.
     */
    dispatchEvent (event : Event ) : boolean ;
    /**
     * Add an event listener to this object that is invoked for all events types
     * the object fires.
     * @param listener The callback or listener object to invoke.
     */
    listenToAllEvents (listener : EventListener | null | ( (a : Event ) => any ) ) : any ;
    release ( ) : any ;
    /**
     * Remove an event listener from this object.
     * @param type The event type for which you wish to remove a listener.
     * @param listener The callback or listener object to remove.
     * @param options Ignored.
     */
    removeEventListener (type : string , listener : EventListener | null | ( (a : Event ) => any ) , options ? : EventListenerOptions | null | boolean ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.FakeEventTarget {
  /**
   * These are the listener types defined in the closure extern for EventTarget.
   */
  type ListenerType = EventListener | null | ( (a : Event ) => any ) ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  /**
   * An interface to standardize how objects are destroyed.
   */
  interface IDestroyable {
    /**
     * Request that this object be destroyed, releasing all resources and shutting
     * down all operations. Returns a Promise which is resolved when destruction
     * is complete. This Promise should never be rejected.
     */
    destroy ( ) : Promise < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  /**
   * An interface to standardize how objects release internal references
   * synchronously. If an object needs to asynchronously release references, then
   * it should use 'shaka.util.IDestroyable'.
   */
  interface IReleasable {
    /**
     * Request that this object release all internal references.
     */
    release ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class Id3Utils {
    private noStructuralTyping_shaka_util_Id3Utils : any;
    /**
     * Returns any adjacent ID3 tags found in data starting at offset, as one
     * block of data
     * @param id3Data - The ID3 data containing one or more ID3 tags
     * @param offset - The offset at which to start searching
     */
    static getID3Data (id3Data : Uint8Array | null , offset ? : number ) : Uint8Array ;
    /**
     * Returns an array of ID3 frames found in all the ID3 tags in the id3Data
     * @param id3Data - The ID3 data containing one or more ID3 tags
     */
    static getID3Frames (id3Data : Uint8Array | null ) : shaka.extern.MetadataFrame [] ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class LanguageUtils {
    private noStructuralTyping_shaka_util_LanguageUtils : any;
    /**
     * Check if |locale1| and |locale2| are language-compatible.
     * Language compatible is when the language component of each locale matches.
     * This means that no matter what region they have (or don't have) as long as
     * the language components match, they are language-compatible.
     * Examples:
     * Locale A | Locale B | Language-Compatible
     * -----------------------------------------
     * en-US    | en-US    | true
     * en-US    | en       | true
     * en-US    | en-CA    | true
     * en-CA    | fr-CA    | false
     */
    static areLanguageCompatible (locale1 : string , locale2 : string ) : boolean ;
    /**
     * Check if |locale1| and |locale2| are locale-compatible.
     * Locale-compatible is defined as all components in each locale match. Since
     * we only respect the language and region components, we only check that
     * the language and region components match.
     * Examples:
     * Locale A | Locale B | Locale Compatible
     * ---------------------------------------
     * en-US    | en-US    | true
     * en       | en-US    | false
     * en-US    | en-CA    | false
     */
    static areLocaleCompatible (locale1 : string , locale2 : string ) : boolean ;
    /**
     * Check if two language codes are siblings. Language codes are siblings if
     * they share the same base language while neither one is the base language.
     * For example, "en-US" and "en-CA" are siblings but "en-US" and "en" are not
     * siblings.
     */
    static areSiblings (a : string , b : string ) : boolean ;
    /**
     * Find the locale in |searchSpace| that comes closest to |target|. If no
     * locale is found to be close to |target|, then |null| will be returned.
     */
    static findClosestLocale (target : string , searchSpace : Iterable < string > ) : string | null ;
    /**
     * Get the normalized base language for a language code.
     */
    static getBase (lang : string ) : string ;
    /**
     * Get the normalized language of the given text stream. Will return 'und' if
     * a language is not found on the text stream.
     * This should always be used to get the language from a text stream.
     */
    static getLocaleForText (stream : shaka.extern.Stream ) : string ;
    /**
     * Get the normalized locale for the given variant. This will look through
     * the variant to find the locale that represents the content in the variant.
     * This will return 'und' if no language can be found.
     * This should always be used to get the locale from a variant.
     */
    static getLocaleForVariant (variant : shaka.extern.Variant ) : string ;
    /**
     * Check if |possibleParent| is the parent locale of |possibleChild|. Because
     * we do not support dialects, the parent-child relationship is a lot simpler.
     * In a parent child relationship:
     * - The parent and child have the same language-component
     * - The parent has no region-component
     * - The child has a region-component
     * Example:
     * Locale A | Locale B | Is A The parent of B?
     * --------------------------------------------
     * en-US    | en-US    | no
     * en-US    | en       | no
     * en       | en-US    | yes
     * en       | en       | no
     * en       | fr       | no
     */
    static isParentOf (possibleParent : string , possibleChild : string ) : boolean ;
    /**
     * Check if |localeA| shares the same parent with |localeB|. Since we don't
     * support dialect, we will only look at language and region. For two locales
     * to be siblings:
     * - Both must have language-components
     * - Both must have region-components
     * - Both must have the same language-component
     * Example:
     * Locale A | Locale B | Siblings?
     * --------------------------------------------
     * en-US    | en-US    | yes
     * en-US    | en-CA    | yes
     * en-US    | en       | no
     * en       | en-US    | no
     * en       | en       | no
     * en       | fr       | no
     */
    static isSiblingOf (localeA : string , localeB : string ) : boolean ;
    /**
     * Normalize a locale. This will take a locale and canonicalize it to a state
     * that we are prepared to work with.
     * We only support with:
     * - language
     * - language-REGION
     * If given a dialect, we will discard it. We will convert any 3-character
     * codes to 2-character codes. We will force language codes to lowercase and
     * region codes to uppercase.
     */
    static normalize (locale : string ) : string ;
    /**
     * Compute a numerical relatedness for language codes.  Language codes with a
     * higher relatedness are a better match.  Unrelated language codes have a
     * relatedness score of 0.
     */
    static relatedness (target : string , candidate : string ) : number ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class MimeUtils {
    private noStructuralTyping_shaka_util_MimeUtils : any;
    /**
     * Takes a MIME type and optional codecs string and produces the full MIME
     * type. Also remove the codecs for raw formats.
     */
    static getFullType (mimeType : string , codecs ? : string ) : string ;
    /**
     * Takes a MIME type and optional codecs string and produces the full MIME
     * type.
     */
    static getFullTypeWithAllCodecs (mimeType : string , codecs ? : string ) : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class Mp4Parser {
    private noStructuralTyping_shaka_util_Mp4Parser : any;
    /**
     * Declare a box type as a Box.
     */
    box (type : string , definition : shaka.util.Mp4Parser.CallbackType ) : shaka.util.Mp4Parser ;
    /**
     * Declare a box type as a Full Box.
     */
    fullBox (type : string , definition : shaka.util.Mp4Parser.CallbackType ) : shaka.util.Mp4Parser ;
    /**
     * Parse the given data using the added callbacks.
     * @param partialOkay If true, allow reading partial payloads from some boxes. If the goal is a child box, we can sometimes find it without enough data to find all child boxes.
     * @param stopOnPartial If true, stop reading if an incomplete box is detected.
     */
    parse (data : ArrayBuffer | ArrayBufferView , partialOkay ? : boolean , stopOnPartial ? : boolean ) : any ;
    /**
     * Parse the next box on the current level.
     * @param absStart The absolute start position in the original byte array.
     * @param partialOkay If true, allow reading partial payloads from some boxes. If the goal is a child box, we can sometimes find it without enough data to find all child boxes.
     * @param stopOnPartial If true, stop reading if an incomplete box is detected.
     */
    parseNext (absStart : number , reader : shaka.util.DataViewReader , partialOkay ? : boolean , stopOnPartial ? : boolean ) : any ;
    /**
     * Stop parsing.  Useful for extracting information from partial segments and
     * avoiding an out-of-bounds error once you find what you are looking for.
     */
    stop ( ) : any ;
    /**
     * Create a callback that tells the Mp4 parser to treat the body of a box as a
     * binary blob and to parse the body's contents using the provided callback.
     */
    static allData (callback : (a : Uint8Array ) => any ) : shaka.util.Mp4Parser.CallbackType ;
    /**
     * A callback that tells the Mp4 parser to treat the body of a box as a series
     * of boxes. The number of boxes is limited by the size of the parent box.
     */
    static children (box : shaka.extern.ParsedBox ) : any ;
    /**
     * Find the header size of the box.
     * Useful for modifying boxes in place or finding the exact offset of a field.
     */
    static headerSize (box : shaka.extern.ParsedBox ) : number ;
    /**
     * A callback that tells the Mp4 parser to treat the body of a box as a sample
     * description. A sample description box has a fixed number of children. The
     * number of children is represented by a 4 byte unsigned integer. Each child
     * is a box.
     */
    static sampleDescription (box : shaka.extern.ParsedBox ) : any ;
    /**
     * Convert an integer type from a box into an ascii string name.
     * Useful for debugging.
     * @param type The type of the box, a uint32.
     */
    static typeToString (type : number ) : string ;
    /**
     * A callback that tells the Mp4 parser to treat the body of a box as a visual
     * sample entry.  A visual sample entry has some fixed-sized fields
     * describing the video codec parameters, followed by an arbitrary number of
     * appended children.  Each child is a box.
     */
    static visualSampleEntry (box : shaka.extern.ParsedBox ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util.Mp4Parser {
  type CallbackType = (a : shaka.extern.ParsedBox ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  /**
   * A utility to combine streams across periods.
   */
  class PeriodCombiner implements shaka.util.IReleasable {
    private noStructuralTyping_shaka_util_PeriodCombiner : any;
    combinePeriods (periods : shaka.extern.Period [] , isDynamic : boolean ) : Promise < any > ;
    getImageStreams ( ) : shaka.extern.Stream [] ;
    getTextStreams ( ) : shaka.extern.Stream [] ;
    getVariants ( ) : shaka.extern.Variant [] ;
    release ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class PlayerConfiguration {
    private noStructuralTyping_shaka_util_PlayerConfiguration : any;
    static createDefault ( ) : shaka.extern.PlayerConfiguration ;
    /**
     * Merges the given configuration changes into the given destination.  This
     * uses the default Player configurations as the template.
     */
    static mergeConfigObjects (destination : shaka.extern.PlayerConfiguration , updates : object , template ? : shaka.extern.PlayerConfiguration ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class StreamUtils {
    private noStructuralTyping_shaka_util_StreamUtils : any;
    static meetsRestrictions (variant : shaka.extern.Variant , restrictions : shaka.extern.Restrictions , maxHwRes : { height : number , width : number } ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class StringUtils {
    private noStructuralTyping_shaka_util_StringUtils : any;
    /**
     * Creates a string from the given buffer, auto-detecting the encoding that is
     * being used.  If it cannot detect the encoding, it will throw an exception.
     */
    static fromBytesAutoDetect (data : ArrayBuffer | ArrayBufferView | null ) : string ;
    /**
     * Creates a string from the given buffer as UTF-16 encoding.
     * @param littleEndian true to read little endian, false to read big.
     * @param noThrow true to avoid throwing in cases where we may expect invalid input.  If noThrow is true and the data has an odd length,it will be truncated.
     */
    static fromUTF16 (data : ArrayBuffer | ArrayBufferView | null , littleEndian : boolean , noThrow ? : boolean ) : string ;
    /**
     * Creates a string from the given buffer as UTF-8 encoding.
     */
    static fromUTF8 (data : ArrayBuffer | ArrayBufferView | null ) : string ;
    /**
     * Resets the fromCharCode method's implementation.
     * For debug use.
     */
    static resetFromCharCode ( ) : any ;
    /**
     * Creates a ArrayBuffer from the given string, converting to UTF-16 encoding.
     */
    static toUTF16 (str : string , littleEndian : boolean ) : ArrayBuffer ;
    /**
     * Creates a ArrayBuffer from the given string, converting to UTF-8 encoding.
     */
    static toUTF8 (str : string ) : ArrayBuffer ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  /**
   * A timer allows a single function to be executed at a later time or at
   * regular intervals.
   */
  class Timer {
    private noStructuralTyping_shaka_util_Timer : any;
    constructor (onTick : ( ) => any ) ;
    /**
     * Stop the timer and clear the previous behaviour. The timer is still usable
     * after calling |stop|.
     */
    stop ( ) : any ;
    /**
     * Have the timer call |onTick| after |seconds| has elapsed unless |stop| is
     * called first.
     */
    tickAfter (seconds : number ) : shaka.util.Timer ;
    /**
     * Have the timer call |onTick| every |seconds| until |stop| is called.
     */
    tickEvery (seconds : number ) : shaka.util.Timer ;
    /**
     * Have the timer call |onTick| now.
     */
    tickNow ( ) : shaka.util.Timer ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class TsParser {
    private noStructuralTyping_shaka_util_TsParser : any;
    /**
     * Clear previous data
     */
    clearData ( ) : any ;
    /**
     * Return the audio data
     */
    getAudioData ( ) : shaka.extern.MPEG_PES [] ;
    /**
     * Return the audio and video codecs
     */
    getCodecs ( ) : { audio : string | null , video : string | null } ;
    /**
     * Return the ID3 metadata
     */
    getMetadata ( ) : shaka.extern.ID3Metadata [] ;
    /**
     * Return the start time for the audio and video
     */
    getStartTime ( ) : { audio : number | null , video : number | null } ;
    /**
     * Return the audio data
     */
    getVideoData ( ) : shaka.extern.MPEG_PES [] ;
    /**
     * Return the video data
     */
    getVideoNalus ( ) : shaka.extern.VideoNalu [] ;
    /**
     * Return the video resolution
     */
    getVideoResolution ( ) : { height : string | null , width : string | null } ;
    /**
     * Parse the given data
     */
    parse (data : Uint8Array | null ) : shaka.util.TsParser ;
    /**
     * Parse AVC Nalus
     * The code is based on hls.js
     * Credit to https://github.com/video-dev/hls.js/blob/master/src/demux/tsdemuxer.ts
     */
    parseAvcNalus (pes : shaka.extern.MPEG_PES , nextPes ? : shaka.extern.MPEG_PES | null ) : shaka.extern.VideoNalu [] ;
    static Timescale : number ;
    /**
     * Check if the passed data corresponds to an MPEG2-TS
     */
    static probe (data : Uint8Array | null ) : boolean ;
    /**
     * Returns the synchronization offset
     */
    static syncOffset (data : Uint8Array | null ) : number ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/dist/shaka-player.ui.debug.externs.js
declare namespace shaka.util {
  class Uint8ArrayUtils {
    private noStructuralTyping_shaka_util_Uint8ArrayUtils : any;
    /**
     * Concatenate buffers.
     */
    static concat ( ...varArgs : ( ArrayBuffer | ArrayBufferView ) [] ) : Uint8Array ;
    /**
     * Convert a base64 string to a Uint8Array.  Accepts either the standard
     * alphabet or the alternate "base64url" alphabet.
     */
    static fromBase64 (str : string ) : Uint8Array ;
    /**
     * Convert a hex string to a Uint8Array.
     */
    static fromHex (str : string ) : Uint8Array ;
    /**
     * Convert a buffer to a base64 string.  The output will always use the
     * alternate encoding/alphabet also known as "base64url".
     * @param padding If true, pad the output with equals signs. Defaults to true.
     */
    static toBase64 (data : ArrayBuffer | ArrayBufferView , padding ? : boolean ) : string ;
    /**
     * Convert a buffer to a hex string.
     */
    static toHex (data : ArrayBuffer | ArrayBufferView ) : string ;
    /**
     * Convert a buffer to a base64 string. The output will be standard
     * alphabet as opposed to base64url safe alphabet.
     */
    static toStandardBase64 (data : ArrayBuffer | ArrayBufferView ) : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/airplay.js
declare namespace _.clutz {
  class AirPlayEvent extends Event {
    private noStructuralTyping_AirPlayEvent : any;
    constructor ( ...a : any [] ) ;
    availability : String | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/awesomplete.js
declare namespace _.clutz {
  class Awesomplete {
    private noStructuralTyping_Awesomplete : any;
    constructor (input : Element ) ;
    list : string [] ;
    minChars : number ;
    evaluate ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace _.clutz {
  function __onGCastApiAvailable (a : boolean ) : any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver {
  class CastChannel {
    private noStructuralTyping_cast_receiver_CastChannel : any;
    send (message : any ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver {
  class CastMessageBus {
    private noStructuralTyping_cast_receiver_CastMessageBus : any;
    broadcast (message : any ) : any ;
    getCastChannel (senderId : string ) : cast.receiver.CastChannel ;
    onMessage : Function | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver.CastMessageBus {
  class Event {
    private noStructuralTyping_cast_receiver_CastMessageBus_Event : any;
    data : any ;
    senderId : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver {
  class CastReceiverManager {
    private noStructuralTyping_cast_receiver_CastReceiverManager : any;
    onSenderConnected : Function | null ;
    onSenderDisconnected : Function | null ;
    onSystemVolumeChanged : Function | null ;
    getCastMessageBus (namespace : string , messageType ? : string ) : cast.receiver.CastMessageBus | null ;
    getSenders ( ) : string [] | null ;
    getSystemVolume ( ) : cast.receiver.system.SystemVolumeData | null ;
    isSystemReady ( ) : boolean ;
    setSystemVolumeLevel (level : number ) : any ;
    setSystemVolumeMuted (muted : number ) : any ;
    start ( ) : any ;
    stop ( ) : any ;
    static getInstance ( ) : cast.receiver.CastReceiverManager | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver.media {
  enum MetadataType {
    GENERIC = 0.0 ,
    MOVIE = 1.0 ,
    MUSIC_TRACK = 3.0 ,
    PHOTO = 4.0 ,
    TV_SHOW = 2.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace cast.receiver.system {
  class SystemVolumeData {
    private noStructuralTyping_cast_receiver_system_SystemVolumeData : any;
    level : number ;
    muted : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  class ApiConfig {
    private noStructuralTyping_chrome_cast_ApiConfig : any;
    constructor (sessionRequest : chrome.cast.SessionRequest | null , sessionListener : Function | null , receiverListener : Function | null , autoJoinPolicy ? : string , defaultActionPolicy ? : string ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  class Error {
    private noStructuralTyping_chrome_cast_Error : any;
    constructor (code : string , description ? : string , details ? : object | null ) ;
    code : string ;
    description : string | null ;
    details : object | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  class Receiver {
    private noStructuralTyping_chrome_cast_Receiver : any;
    friendlyName : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  class Session {
    private noStructuralTyping_chrome_cast_Session : any;
    receiver : chrome.cast.Receiver | null ;
    sessionId : string ;
    status : string ;
    addMessageListener (namespace : string , listener : Function | null ) : any ;
    addUpdateListener (listener : Function | null ) : any ;
    leave (successCallback : Function | null , errorCallback : Function | null ) : any ;
    removeMessageListener (namespace : string , listener : Function | null ) : any ;
    removeUpdateListener (listener : Function | null ) : any ;
    sendMessage (namespace : string , message : object | string , successCallback : Function | null , errorCallback : Function | null ) : any ;
    stop (successCallback : Function | null , errorCallback : Function | null ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  class SessionRequest {
    private noStructuralTyping_chrome_cast_SessionRequest : any;
    constructor (appId : string , capabilities : ( object | null ) [] | null , timeout : number | null , androidReceiverCompatible : boolean , credentialsData : object | null ) ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast.SessionStatus {
  let STOPPED : string ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/chromecast.js
declare namespace chrome.cast {
  let isAvailable : boolean ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/cmcd.js
declare namespace _.clutz {
  type CmcdData = { bl ? : number , br ? : number , bs ? : boolean , cid ? : string , d ? : number , dl ? : number , mtp ? : number , nor ? : string , nrr ? : string , ot ? : string , pr ? : number , rtp ? : number , sf ? : string , sid ? : string , st ? : string , su ? : boolean , tb ? : number , v ? : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.AdErrorEvent {
  enum Type {
    AD_ERROR = 'AD_ERROR' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.AdEvent {
  enum Type {
    AD_BREAK_READY = 'AD_BREAK_READY' ,
    AD_BUFFERING = 'AD_BUFFERING' ,
    AD_ERROR = 'AD_ERROR' ,
    AD_METADATA = 'AD_METADATA' ,
    AD_PROGRESS = 'AD_PROGRESS' ,
    ALL_ADS_COMPLETED = 'ALL_ADS_COMPLETED' ,
    CLICK = 'CLICK' ,
    COMPLETE = 'COMPLETE' ,
    CONTENT_PAUSE_REQUESTED = 'CONTENT_PAUSE_REQUESTED' ,
    CONTENT_RESUME_REQUESTED = 'CONTENT_RESUME_REQUESTED' ,
    DURATION_CHANGE = 'DURATION_CHANGE' ,
    FIRST_QUARTILE = 'FIRST_QUARTILE' ,
    IMPRESSION = 'IMPRESSION' ,
    INTERACTION = 'INTERACTION' ,
    LINEAR_CHANGED = 'LINEAR_CHANGED' ,
    LOADED = 'LOADED' ,
    LOG = 'LOG' ,
    MIDPOINT = 'MIDPOINT' ,
    PAUSED = 'PAUSED' ,
    RESUMED = 'RESUMED' ,
    SKIPPABLE_STATE_CHANGED = 'SKIPPABLE_STATE_CHANGED' ,
    SKIPPED = 'SKIPPED' ,
    STARTED = 'STARTED' ,
    THIRD_QUARTILE = 'THIRD_QUARTILE' ,
    USER_CLOSE = 'USER_CLOSE' ,
    VOLUME_CHANGED = 'VOLUME_CHANGED' ,
    VOLUME_MUTED = 'VOLUME_MUTED' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  class AdsLoader implements EventTarget {
    private noStructuralTyping_google_ima_AdsLoader : any;
    constructor (container : google.ima.AdDisplayContainer ) ;
    addEventListener ( ) : any ;
    contentComplete ( ) : any ;
    destroy ( ) : any ;
    dispatchEvent ( ) : any ;
    getSettings ( ) : google.ima.ImaSdkSettings | null ;
    removeEventListener ( ) : any ;
    requestAds (request : google.ima.AdsRequest ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  class AdsManager implements EventTarget {
    private noStructuralTyping_google_ima_AdsManager : any;
    addEventListener ( ) : any ;
    destroy ( ) : any ;
    dispatchEvent ( ) : any ;
    getAdSkippableState ( ) : boolean ;
    getCuePoints ( ) : number [] ;
    getRemainingTime ( ) : number ;
    getVolume ( ) : any ;
    init (width : number , height : number , viewMode : google.ima.ViewMode ) : any ;
    pause ( ) : any ;
    removeEventListener ( ) : any ;
    resize (width : number , height : number , viewMode : google.ima.ViewMode ) : any ;
    resume ( ) : any ;
    setVolume (volume : number ) : any ;
    skip ( ) : any ;
    start ( ) : any ;
    stop ( ) : any ;
    updateAdsRenderingSettings (adsRenderingSettings : google.ima.AdsRenderingSettings ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.AdsManagerLoadedEvent {
  enum Type {
    ADS_MANAGER_LOADED = 'ADS_MANAGER_LOADED' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  type AdsRenderingSettings = { autoAlign : boolean , bitrate : number , enablePreloading : boolean , loadVideoTimeout : number , mimeTypes : string [] | null , playAdsAfterTime : number , restoreCustomPlaybackStateOnAdBreakComplete : boolean , uiElements : string [] | null , useStyledLinearAds : boolean , useStyledNonLinearAds : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  type AdsRequest = { adTagUrl ? : string , adsResponse ? : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.ImaSdkSettings {
  enum VpaidMode {
    DISABLED = 0.0 ,
    ENABLED = 1.0 ,
    INSECURE = 2.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  enum ViewMode {
    FULLSCREEN = 'FULLSCREEN' ,
    NORMAL = 'NORMAL' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.dai.api {
  enum OmidAccessMode {
    DOMAIN = 'domain' ,
    FULL = 'full' ,
    LIMITED = 'limited' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.dai.api {
  enum OmidVerificationVendor {
    COMSCORE = 7.0 ,
    DOUBLEVERIFY = 3.0 ,
    GOOGLE = 9.0 ,
    INTEGRAL_AD_SCIENCE = 4.0 ,
    MEETRICS = 8.0 ,
    MOAT = 2.0 ,
    NIELSEN = 6.0 ,
    OTHER = 1.0 ,
    PIXELATE = 5.0 ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.dai.api.StreamEvent {
  enum Type {
    AD_BREAK_ENDED = 'adBreakEnded' ,
    AD_BREAK_STARTED = 'adBreakStarted' ,
    AD_PERIOD_ENDED = 'adPeriodEnded' ,
    AD_PERIOD_STARTED = 'adPeriodStarted' ,
    AD_PROGRESS = 'adProgress' ,
    CLICK = 'click' ,
    COMPLETE = 'complete' ,
    CUEPOINTS_CHANGED = 'cuepointsChanged' ,
    ERROR = 'error' ,
    FIRST_QUARTILE = 'firstquartile' ,
    LOADED = 'loaded' ,
    MIDPOINT = 'midpoint' ,
    SKIPPABLE_STATE_CHANGED = 'skippableStateChanged' ,
    SKIPPED = 'skip' ,
    STARTED = 'started' ,
    STREAM_INITIALIZED = 'streamInitialized' ,
    THIRD_QUARTILE = 'thirdquartile' ,
    VIDEO_CLICKED = 'videoClicked' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.dai.api {
  class StreamManager implements EventTarget {
    private noStructuralTyping_google_ima_dai_api_StreamManager : any;
    constructor (videoElement : HTMLMediaElement | null , adUiElement ? : HTMLElement | null , uiSettings ? : google.ima.dai.api.UiSettings | null ) ;
    addEventListener (type : string | any [] | null , handler : null | object , capture ? : boolean | AddEventListenerOptions , handlerScope ? : object | null ) : any ;
    contentTimeForStreamTime (streamTime : number ) : any ;
    dispatchEvent ( ) : any ;
    onTimedMetadata (metadata : object | null ) : any ;
    previousCuePointForStreamTime (streamTime : number ) : any ;
    processMetadata (type : string , data : Uint8Array | null | string , timestamp : number ) : any ;
    removeEventListener ( ) : any ;
    replaceAdTagParameters (adTagParameters : object | null ) : any ;
    requestStream (streamRequest : google.ima.dai.api.StreamRequest | null ) : any ;
    reset ( ) : any ;
    setClickElement (clickElement : Element | null ) : any ;
    streamTimeForContentTime (contentTime : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima.dai.api.StreamRequest {
  enum StreamFormat {
    DASH = 'dash' ,
    HLS = 'hls' ,
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/ima.js
declare namespace google.ima {
  let settings : google.ima.ImaSdkSettings ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/jwk_set.js
declare namespace _.clutz {
  /**
   * A JSON Web Key.
   */
  class JWK {
    private noStructuralTyping_JWK : any;
    /**
     * A key in base 64.  Used with kty="oct".
     */
    k : string ;
    /**
     * A key ID.  Any ASCII string.
     */
    kid : string ;
    /**
     * A key type.  One of:
     * 1. "oct" (symmetric key octect sequence)
     * 2. "RSA" (RSA key)
     * 3. "EC" (elliptical curve key)
     * Use "oct" for clearkey.
     */
    kty : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/jwk_set.js
declare namespace _.clutz {
  /**
   * A JSON Web Key set.
   */
  class JWKSet {
    private noStructuralTyping_JWKSet : any;
    keys : ( JWK | null ) [] | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/lcevc.js
declare namespace LcevcDil {
  /**
   * LCEVC DIL constructor
   */
  class LcevcDIL {
    private noStructuralTyping_LcevcDil_LcevcDIL : any;
    constructor (media : HTMLVideoElement | null , canvas : HTMLCanvasElement | null , dilConfig : shaka.extern.LcevcConfiguration ) ;
    /**
     * Append the video buffers before they are appended to
     * Media Source Extensions SourceBuffer. Here the lcevc data
     * will be parsed and managed to enhance frames based on timestamps.
     * @param data Video Buffer Data.
     * @param type Type of Video Buffer Data.
     * @param variantId Variant that the fragment belongs to.
     */
    appendBuffer (data : ArrayBuffer | ArrayBufferView , type : string , variantId : number ) : any ;
    /**
     * Close LCEVC DIL
     */
    close ( ) : any ;
    /**
     * Set container Format for LCEVC Data Parsing.
     * @param containerFormat container type of the stream.
     */
    setContainerFormat (containerFormat : number ) : any ;
    /**
     * Set current variant as variantId to the LCEVC decoder
     * @param autoBufferSwitch is lcevcDil mode that switches variant when the downloaded buffer from last variant has finished playing and buffers from the new variant starts to play.
     */
    setLevelSwitching (variantId : number , autoBufferSwitch : boolean ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/lcevc.js
declare namespace LcevcDil.SupportObject {
  /**
   * LCEVC Support CheckList Error if any.
   */
  let SupportError : string ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/lcevc.js
declare namespace LcevcDil.SupportObject {
  /**
   * LCEVC Support Checklist Result
   */
  let SupportStatus : boolean ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/lcevc.js
declare namespace LcevcDil.SupportObject {
  /**
   * Check if canvas has WebGL support
   */
  function webGLSupport (canvas : HTMLCanvasElement | null ) : boolean ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/mdl.js
declare namespace _.clutz {
  class MaterialLayout {
    private noStructuralTyping_MaterialLayout : any;
    Constant_ : { MENU_ICON : string } ;
    toggleDrawer ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/mediasession.js
declare namespace _.clutz {
  class MediaMetadata {
    private noStructuralTyping_MediaMetadata : any;
    constructor (options : any ) ;
    artist : string ;
    artwork : object ;
    title : string ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/mediasession.js
declare namespace _.clutz {
  class MediaSession {
    private noStructuralTyping_MediaSession : any;
    metadata : MediaMetadata | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/mux.js
declare namespace muxjs.mp4 {
  class Transmuxer {
    private noStructuralTyping_muxjs_mp4_Transmuxer : any;
    constructor (options ? : object | null ) ;
    /**
     * Remove all handlers and clean up.
     */
    dispose ( ) : any ;
    flush ( ) : any ;
    /**
     * Remove a handler for a specified event type.
     * @param type Event name
     * @param listener The callback to be removed
     */
    off (type : string , listener : Function | null ) : any ;
    /**
     * Add a handler for a specified event type.
     * @param type Event name
     * @param listener The callback to be invoked
     */
    on (type : string , listener : Function | null ) : any ;
    push (data : Uint8Array ) : any ;
    setBaseMediaDecodeTime (time : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/mux.js
declare namespace muxjs.mp4.Transmuxer {
  type Segment = { data : Uint8Array , initSegment : Uint8Array } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/pictureinpicture.js
declare namespace _.clutz {
  class DocumentPictureInPicture implements EventTarget {
    private noStructuralTyping_DocumentPictureInPicture : any;
    addEventListener (type : any , listener : any , options : any ) : any ;
    dispatchEvent (event : any ) : any ;
    removeEventListener (type : any , listener : any , options : any ) : any ;
    requestWindow (options : DocumentPictureInPictureOptions ) : Promise < Window | null > ;
    window : Window | null ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/pictureinpicture.js
declare namespace _.clutz {
  type DocumentPictureInPictureOptions = { height ? : number , width ? : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/polyfill.js
declare namespace window {
  let shakaMediaKeysPolyfill : boolean ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/prefixed_eme.js
declare namespace _.clutz {
  class MediaKeyError {
    private noStructuralTyping_MediaKeyError : any;
    code : number ;
    systemCode : number ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/prefixed_eme.js
declare namespace _.clutz {
  class MediaKeyEvent extends Event {
    private noStructuralTyping_MediaKeyEvent : any;
    constructor (type : string , eventInitDict ? : object | null ) ;
    defaultURL : string ;
    errorCode : MediaKeyError | null ;
    initData : Uint8Array ;
    keySystem : string ;
    message : Uint8Array ;
    sessionId : string ;
    systemCode : number ;
    target : HTMLMediaElement ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/abortable.js
declare namespace shaka.extern {
  /**
   * A representation of an abortable operation.  Note that these are not
   * cancelable.  Cancelation implies undoing what has been done so far,
   * whereas aborting only means that further work is stopped.
   */
  interface IAbortableOperation < T > {
    /**
     * Can be called by anyone holding this object to abort the underlying
     * operation.  This is not cancelation, and will not necessarily result in
     * any work being undone.  abort() should return a Promise which is resolved
     * when the underlying operation has been aborted.  The returned Promise
     * should never be rejected.
     */
    abort ( ) : Promise < any > ;
    finally (onFinal : (a : boolean ) => any ) : shaka.extern.IAbortableOperation < T > ;
    /**
     * A Promise which represents the underlying operation.  It is resolved when
     * the operation is complete, and rejected if the operation fails or is
     * aborted.  Aborted operations should be rejected with a shaka.util.Error
     * object using the error code OPERATION_ABORTED.
     */
    promise : Promise < T > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/abr_manager.js
declare namespace shaka.extern {
  /**
   * An object which selects Streams from a set of possible choices.  This also
   * watches for system changes to automatically adapt for the current streaming
   * requirements.  For example, when the network slows down, this class is in
   * charge of telling the Player which streams to switch to in order to reduce
   * the required bandwidth.
   *
   * This class is given a set of streams to choose from when the Player starts
   * up.  This class should store these and use them to make future decisions
   * about ABR.  It is up to this class how those decisions are made.  All the
   * Player will do is tell this class what streams to choose from.
   */
  interface AbrManager {
    /**
     * Chooses one variant to switch to.  Called by the Player.
     */
    chooseVariant ( ) : shaka.extern.Variant ;
    /**
     * Sets the ABR configuration.
     *
     * It is the responsibility of the AbrManager implementation to implement the
     * restrictions behavior described in shaka.extern.AbrConfiguration.
     */
    configure (config : shaka.extern.AbrConfiguration ) : any ;
    /**
     * Disables automatic Stream suggestions. After this, the AbrManager may not
     * call switchCallback().
     */
    disable ( ) : any ;
    /**
     * Enables automatic Variant choices from the last ones passed to setVariants.
     * After this, the AbrManager may call switchCallback() at any time.
     */
    enable ( ) : any ;
    /**
     * Gets an estimate of the current bandwidth in bit/sec.  This is used by the
     * Player to generate stats.
     */
    getBandwidthEstimate ( ) : number ;
    /**
     * Initializes the AbrManager.
     */
    init (switchCallback : shaka.extern.AbrManager.SwitchCallback ) : any ;
    /**
     * Updates manager playback rate.
     */
    playbackRateChanged (rate : number ) : any ;
    /**
     * Request that this object release all internal references.
     */
    release ( ) : any ;
    /**
     * Notifies the AbrManager that a segment has been downloaded (includes MP4
     * SIDX data, WebM Cues data, initialization segments, and media segments).
     * @param deltaTimeMs The duration, in milliseconds, that the request took to complete.
     * @param numBytes The total number of bytes transferred.
     */
    segmentDownloaded (deltaTimeMs : number , numBytes : number ) : any ;
    /**
     * Set media element.
     */
    setMediaElement (mediaElement : HTMLMediaElement | null ) : any ;
    /**
     * Updates manager's variants collection.
     */
    setVariants (variants : shaka.extern.Variant [] ) : any ;
    /**
     * Stops any background timers and frees any objects held by this instance.
     * This will only be called after a call to init.
     */
    stop ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/abr_manager.js
declare namespace shaka.extern.AbrManager {
  /**
   * A factory for creating the abr manager.
   */
  type Factory = ( ) => shaka.extern.AbrManager ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/abr_manager.js
declare namespace shaka.extern.AbrManager {
  /**
   * A callback into the Player that should be called when the AbrManager decides
   * it's time to change to a different variant.
   *
   * The first argument is a variant to switch to.
   *
   * The second argument is an optional boolean. If true, all data will be removed
   * from the buffer, which will result in a buffering event. Unless a third
   * argument is passed.
   *
   * The third argument in an optional number that specifies how much data (in
   * seconds) should be retained when clearing the buffer. This can help achieve
   * a fast switch that doesn't involve a buffering event. A minimum of two video
   * segments should always be kept buffered to avoid temporary hiccups.
   */
  type SwitchCallback = (a : shaka.extern.Variant , b ? : boolean , c ? : number ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/ads.js
declare namespace shaka.extern {
  type AdCuePoint = { end : number | null , start : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/ads.js
declare namespace shaka.extern {
  type AdsStats = { loadTimes : number [] , playedCompletely : number , skipped : number , started : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/ads.js
declare namespace shaka.extern {
  /**
   * Interface for Ad objects.
   */
  interface IAd extends shaka.util.IReleasable {
    canSkipNow ( ) : boolean ;
    getAdId ( ) : string ;
    getAdvertiserName ( ) : string ;
    getCreativeAdId ( ) : string ;
    getDescription ( ) : string ;
    getDuration ( ) : number ;
    getMediaUrl ( ) : string | null ;
    /**
     * Gets the minimum suggested duration.  Defaults to being equivalent to
     * getDuration() for server-side ads.
     */
    getMinSuggestedDuration ( ) : number ;
    getPodIndex ( ) : number ;
    getPositionInSequence ( ) : number ;
    getRemainingTime ( ) : number ;
    getSequenceLength ( ) : number ;
    getTimeOffset ( ) : number ;
    getTimeUntilSkippable ( ) : number ;
    getTitle ( ) : string ;
    getVastMediaBitrate ( ) : number ;
    getVastMediaHeight ( ) : number ;
    getVastMediaWidth ( ) : number ;
    getVolume ( ) : number ;
    isLinear ( ) : boolean ;
    isMuted ( ) : boolean ;
    isPaused ( ) : boolean ;
    isSkippable ( ) : boolean ;
    pause ( ) : any ;
    play ( ) : any ;
    resize (width : number , height : number ) : any ;
    setMuted (muted : boolean ) : any ;
    setVolume (volume : number ) : any ;
    skip ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/ads.js
declare namespace shaka.extern {
  /**
   * An object that's responsible for all the ad-related logic
   * in the player.
   */
  interface IAdManager extends EventTarget {
    /**
     * Called by the Player to provide an updated configuration any time it
     * changes.
     * Must be called at least once before init*().
     */
    configure (config : shaka.extern.AdsConfiguration ) : any ;
    getServerSideCuePoints ( ) : shaka.extern.AdCuePoint [] ;
    /**
     * Get statistics for the current playback session. If the player is not
     * playing content, this will return an empty stats object.
     */
    getStats ( ) : any ;
    initClientSide (adContainer : HTMLElement , video : HTMLMediaElement , adsRenderingSettings : google.ima.AdsRenderingSettings | null ) : any ;
    initServerSide (adContainer : HTMLElement , video : HTMLMediaElement ) : any ;
    onAssetUnload ( ) : any ;
    onCueMetadataChange (value : shaka.extern.MetadataFrame ) : any ;
    onDashTimedMetadata (region : shaka.extern.TimelineRegionInfo ) : any ;
    onHlsTimedMetadata (metadata : shaka.extern.ID3Metadata , timestampOffset : number ) : any ;
    release ( ) : any ;
    replaceServerSideAdTagParameters (adTagParameters : object | null ) : any ;
    requestClientSideAds (imaRequest : google.ima.AdsRequest ) : any ;
    requestServerSideStream (imaRequest : google.ima.dai.api.StreamRequest , backupUrl ? : string ) : Promise < string > ;
    setLocale (locale : string ) : any ;
    updateClientSideAdsRenderingSettings (adsRenderingSettings : google.ima.AdsRenderingSettings ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/ads.js
declare namespace shaka.extern.IAdManager {
  /**
   * A factory for creating the ad manager.
   */
  type Factory = ( ) => shaka.extern.IAdManager ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern {
  type CaptionDecoderPlugin = ( ) => shaka.extern.ICaptionDecoder ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern {
  type CeaParserPlugin = ( ) => shaka.extern.ICeaParser ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern {
  /**
   * Interface for decoding inband closed captions from packets.
   */
  interface ICaptionDecoder {
    /**
     * Clears the decoder state completely.
     * Should be used when an action renders the decoder state invalid,
     * e.g. unbuffered seeks.
     */
    clear ( ) : any ;
    /**
     * Decodes all currently extracted packets and then clears them.
     * This should be called once for a set of extracts (see comment on extract).
     */
    decode ( ) : shaka.extern.ICaptionDecoder.ClosedCaption [] ;
    /**
     * Extracts packets and prepares them for decoding. In a given media fragment,
     * all the caption packets found in its SEI messages should be extracted by
     * successive calls to extract(), followed by a single call to decode().
     * @param userDataSeiMessage This is a User Data registered by Rec.ITU-T T.35 SEI message. It is described in sections D.1.6 and D.2.6 of Rec. ITU-T H.264 (06/2019).
     * @param pts PTS when this packet was received, in seconds.
     */
    extract (userDataSeiMessage : Uint8Array , pts : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern.ICaptionDecoder {
  /**
   * Parsed Cue.
   */
  type ClosedCaption = { cue : shaka.text.Cue , stream : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern {
  /**
   * Interface for parsing inband closed caption data from MP4 streams.
   */
  interface ICeaParser {
    /**
     * Initializes the parser with init segment data.
     * @param initSegment init segment to parse.
     */
    init (initSegment : ArrayBuffer | ArrayBufferView ) : any ;
    /**
     * Parses the stream and extracts closed captions packets.
     * @param mediaSegment media segment to parse.
     */
    parse (mediaSegment : ArrayBuffer | ArrayBufferView ) : shaka.extern.ICeaParser.CaptionPacket [] ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/cea.js
declare namespace shaka.extern.ICeaParser {
  type CaptionPacket = { packet : Uint8Array , pts : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/codecs.js
declare namespace shaka.extern {
  type MPEG_PES = { data : Uint8Array | null , dts : number | null , packetLength : number , pts : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/codecs.js
declare namespace shaka.extern {
  type VideoNalu = { data : Uint8Array , fullData : Uint8Array , time : number | null , type : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/error.js
declare namespace shaka.extern {
  interface Error {
    category : shaka.util.Error.Category ;
    code : shaka.util.Error.Code ;
    data : any [] ;
    handled : boolean ;
    severity : shaka.util.Error.Severity ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/error.js
declare namespace shaka.extern {
  type RestrictionInfo = { hasAppRestrictions : boolean , missingKeys : string [] , restrictedKeyStatuses : string [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  /**
   * Creates a SegmentIndex; returns a Promise that resolves after the
   * SegmentIndex has been created.
   */
  type CreateSegmentIndexFunction = ( ) => Promise < any > ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type DrmInfo = { audioRobustness : string , distinctiveIdentifierRequired : boolean , initData : shaka.extern.InitDataOverride [] | null , keyIds : Set < string > | null , keySystem : string , licenseServerUri : string , persistentStateRequired : boolean , serverCertificate : Uint8Array | null , serverCertificateUri : string , sessionType : string , videoRobustness : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  /**
   * A function that fetches the crypto keys for AES-128.
   * Returns a promise that resolves when the keys have been fetched.
   */
  type FetchCryptoKeysFunction = ( ) => Promise < any > ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type HlsAes128Key = { cryptoKey ? : webCrypto.CryptoKey | null , fetchKey ? : shaka.extern.CreateSegmentIndexFunction , firstMediaSequenceNumber : number , iv ? : Uint8Array , method : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type InitDataOverride = { initData : Uint8Array , initDataType : string , keyId : string | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type Manifest = { ignoreManifestTimestampsInSegmentsMode : boolean , imageStreams : shaka.extern.Stream [] , minBufferTime : number , offlineSessionIds : string [] , presentationTimeline : shaka.media.PresentationTimeline , sequenceMode : boolean , serviceDescription : shaka.extern.ServiceDescription | null , textStreams : shaka.extern.Stream [] , type : string , variants : shaka.extern.Variant [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type MssPrivateData = { codecPrivateData : string | null , duration : number , timescale : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type Period = { audioStreams : shaka.extern.Stream [] , id : string , imageStreams : shaka.extern.Stream [] , textStreams : shaka.extern.Stream [] , videoStreams : shaka.extern.Stream [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type ServiceDescription = { maxLatency : number | null , maxPlaybackRate : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type Stream = { accessibilityPurpose : shaka.media.ManifestParser.AccessibilityPurpose | null , audioSamplingRate : number | null , bandwidth ? : number , channelsCount : number | null , closeSegmentIndex ? : ( ) => any , closedCaptions : Map < string , string > | null , codecs : string , createSegmentIndex : shaka.extern.CreateSegmentIndexFunction , drmInfos : shaka.extern.DrmInfo [] , emsgSchemeIdUris : string [] | null , encrypted : boolean , external : boolean , forced : boolean , frameRate ? : number , hdr ? : string , height ? : number , id : number , keyIds : Set < string > , kind ? : string , label : string | null , language : string , matchedStreams ? : any [] , mimeType : string , mssPrivateData ? : shaka.extern.MssPrivateData , originalId : string | null , originalLanguage : string | null , pixelAspectRatio ? : string , primary : boolean , roles : string [] , segmentIndex : shaka.media.SegmentIndex | null , spatialAudio : boolean , tilesLayout ? : string , trickModeVideo : any , type : string , width ? : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest.js
declare namespace shaka.extern {
  type Variant = { allowedByApplication : boolean , allowedByKeySystem : boolean , audio : shaka.extern.Stream | null , bandwidth : number , decodingInfos : ( any | null ) [] , disabledUntilTime : number , id : number , language : string , primary : boolean , video : shaka.extern.Stream | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest_parser.js
declare namespace shaka.extern {
  /**
   * Parses media manifests and handles manifest updates.
   *
   * Given a URI where the initial manifest is found, a parser will request the
   * manifest, parse it, and return the resulting Manifest object.
   *
   * If the manifest requires updates (e.g. for live media), the parser will use
   * background timers to update the same Manifest object.
   *
   * There are many ways for |start| and |stop| to be called. Implementations
   * should support all cases:
   *
   * BASIC
   * await parser.start(uri, playerInterface);
   * await parser.stop();
   *
   * INTERRUPTING
   * const p = parser.start(uri, playerInterface);
   * await parser.stop();
   * await p;
   *
   * |p| should be rejected with an OPERATION_ABORTED error.
   *
   * STOPPED BEFORE STARTING
   * await parser.stop();
   */
  interface ManifestParser {
    /**
     * Called by the Player to provide an updated configuration any time the
     * configuration changes.  Will be called at least once before start().
     */
    configure (config : shaka.extern.ManifestConfiguration ) : any ;
    /**
     * Tells the parser that the expiration time of an EME session has changed.
     * Implementing this is optional.
     */
    onExpirationUpdated (sessionId : string , expiration : number ) : any ;
    /**
     * Initialize and start the parser. When |start| resolves, it should return
     * the initial version of the manifest. |start| will only be called once. If
     * |stop| is called while |start| is pending, |start| should reject.
     * @param uri The URI of the manifest.
     * @param playerInterface The player interface contains the callbacks and members that the parser can use to communicate with the player and outside world.
     */
    start (uri : string , playerInterface : shaka.extern.ManifestParser.PlayerInterface ) : Promise < shaka.extern.Manifest > ;
    /**
     * Tell the parser that it must stop and free all internal resources as soon
     * as possible. Only once all internal resources are stopped and freed will
     * the promise resolve. Once stopped a parser will not be started again.
     *
     * The parser should support having |stop| called multiple times and the
     * promise should always resolve.
     */
    stop ( ) : Promise < any > ;
    /**
     * Tells the parser to do a manual manifest update.  Implementing this is
     * optional.  This is only called when 'emsg' boxes are present.
     */
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest_parser.js
declare namespace shaka.extern.ManifestParser {
  /**
   * A factory for creating the manifest parser.  This function is registered with
   * shaka.media.ManifestParser to create parser instances.
   */
  type Factory = ( ) => shaka.extern.ManifestParser ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/manifest_parser.js
declare namespace shaka.extern.ManifestParser {
  type PlayerInterface = { enableLowLatencyMode : ( ) => any , filter : (a : shaka.extern.Manifest ) => Promise < any > , isAutoLowLatencyMode : ( ) => boolean , isLowLatencyMode : ( ) => boolean , makeTextStreamsForClosedCaptions : (a : shaka.extern.Manifest ) => any , networkingEngine : shaka.net.NetworkingEngine , newDrmInfo : (a : shaka.extern.Stream ) => any , onError : (a : shaka.util.Error ) => any , onEvent : shaka.util.EventManager.ListenerType , onTimelineRegionAdded : (a : shaka.extern.TimelineRegionInfo ) => any , updateDuration : ( ) => any } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/mp4_parser.js
declare namespace shaka.extern {
  type ParsedBox = { flags : number | null , has64BitSize : boolean , name : string , parser : shaka.util.Mp4Parser , partialOkay : boolean , reader : shaka.util.DataViewReader , size : number , start : number , version : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type HeadersReceived = (a : { [ key: string ]: string } ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type ProgressUpdated = (a : number , b : number , c : number ) => any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type Request = { allowCrossSiteCredentials : boolean , body : ArrayBuffer | ArrayBufferView | null , drmInfo : shaka.extern.DrmInfo | null , headers : { [ key: string ]: string } , initData : Uint8Array | null , initDataType : string | null , licenseRequestType : string | null , method : string , retryParameters : shaka.extern.RetryParameters , sessionId : string | null , streamDataCallback : ( (a : ArrayBuffer | ArrayBufferView ) => Promise < any > ) | null , uris : string [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type RequestContext = { segment ? : shaka.media.SegmentReference | null , stream ? : shaka.extern.Stream , type ? : shaka.net.NetworkingEngine.AdvancedRequestType } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  /**
   * Defines a filter for requests.  This filter takes the request and modifies
   * it before it is sent to the scheme plugin.
   * The RequestType describes the basic type of the request (manifest, segment,
   * etc). The optional RequestContext will be provided where applicable to
   * provide additional infomation about the request. A request filter can run
   * asynchronously by returning a promise; in this case, the request will not be
   * sent until the promise is resolved.
   */
  type RequestFilter = (a : shaka.net.NetworkingEngine.RequestType , b : shaka.extern.Request , c ? : shaka.extern.RequestContext ) => Promise < any > | void ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type Response = { data : ArrayBuffer | ArrayBufferView , fromCache ? : boolean , headers : { [ key: string ]: string } , originalUri : string , status ? : number , timeMs ? : number , uri : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  /**
   * Defines a filter for responses.  This filter takes the response and modifies
   * it before it is returned.
   * The RequestType describes the basic type of the request (manifest, segment,
   * etc). The optional RequestContext will be provided where applicable to
   * provide additional infomation about the request. A response filter can run
   * asynchronously by returning a promise.
   */
  type ResponseFilter = (a : shaka.net.NetworkingEngine.RequestType , b : shaka.extern.Response , c ? : shaka.extern.RequestContext ) => Promise < any > | void ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type RetryParameters = { backoffFactor : number , baseDelay : number , connectionTimeout : number , fuzzFactor : number , maxAttempts : number , stallTimeout : number , timeout : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/net.js
declare namespace shaka.extern {
  type SchemePlugin = (a : string , b : shaka.extern.Request , c : shaka.net.NetworkingEngine.RequestType , d : shaka.extern.ProgressUpdated , e : shaka.extern.HeadersReceived ) => shaka.extern.IAbortableOperation < shaka.extern.Response > ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type EmeSessionDB = { audioCapabilities : { contentType : string , robustness : string } [] , keySystem : string , licenseUri : string , serverCertificate : Uint8Array | null , sessionId : string , videoCapabilities : { contentType : string , robustness : string } [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  /**
   * Similar to storage cells (shaka.extern.StorageCell), an EmeSessionStorageCell
   * stores data persistently.  This only stores the license's session info, not
   * the license itself.  The license itself is stored using EME.
   */
  interface EmeSessionStorageCell {
    /**
     * Adds the given sessions to the store.
     */
    add (sessions : shaka.extern.EmeSessionDB [] ) : Promise < any > ;
    /**
     * Free all resources used by this cell. This won't affect the stored content.
     */
    destroy ( ) : Promise < any > ;
    /**
     * Gets the currently stored sessions.
     */
    getAll ( ) : Promise < shaka.extern.EmeSessionDB [] > ;
    /**
     * Removes the given session IDs from the store.
     */
    remove (sessionIds : string [] ) : Promise < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type ManifestDB = { appMetadata : object | null , creationTime : number , drmInfo : shaka.extern.DrmInfo | null , duration : number , expiration : number , isIncomplete ? : boolean , originalManifestUri : string , sequenceMode ? : boolean , sessionIds : string [] , size : number , streams : shaka.extern.StreamDB [] , type ? : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type OfflineSupport = { basic : boolean , encrypted : { [ key: string ]: boolean } } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type SegmentDB = { appendWindowEnd : number , appendWindowStart : number , dataKey : number , endTime : number , initSegmentKey : number | null , pendingInitSegmentRefId ? : string , pendingSegmentRefId ? : string , startTime : number , tilesLayout : string | null , timestampOffset : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type SegmentDataDB = { data : ArrayBuffer } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  /**
   * An interface that defines access to collection of segments and manifests. All
   * methods are designed to be batched operations allowing the implementations to
   * optimize their operations based on how they store data.
   *
   * The storage cell is one of two exposed APIs used to control where and how
   * offline content is saved. The storage cell is responsible for converting
   * information between its internal structures and the external (library)
   * structures.
   */
  interface StorageCell {
    /**
     * Add a group of manifests. Will return a promise that resolves with a list
     * of keys for each manifest. If one manifest fails to be added, all manifests
     * should fail to be added.
     */
    addManifests (manifests : shaka.extern.ManifestDB [] ) : Promise < number [] > ;
    /**
     * Add a group of segments. Will return a promise that resolves with a list
     * of keys for each segment. If one segment fails to be added, all segments
     * should fail to be added.
     */
    addSegments (segments : shaka.extern.SegmentDataDB [] ) : Promise < number [] > ;
    /**
     * Free all resources used by this cell. This should not affect the stored
     * content.
     */
    destroy ( ) : Promise < any > ;
    /**
     * Get all manifests stored in this cell. Since manifests are small compared
     * to the asset they describe, it is assumed that it is feasible to have them
     * all in main memory at one time.
     */
    getAllManifests ( ) : Promise < Map < number , shaka.extern.ManifestDB > > ;
    /**
     * Get a group of manifests using their keys to identify them. If any key is
     * not found, the promise chain will be rejected.
     */
    getManifests (keys : number [] ) : Promise < shaka.extern.ManifestDB [] > ;
    /**
     * Get a group of segments using their keys to identify them. If any key is
     * not found, the promise chain will be rejected.
     */
    getSegments (keys : number [] ) : Promise < shaka.extern.SegmentDataDB [] > ;
    /**
     * Check if the cell can support new keys. If a cell has a fixed key space,
     * then all add-operations will fail as no new keys can be added. All
     * remove-operations and update-operations should still work.
     */
    hasFixedKeySpace ( ) : boolean ;
    /**
     * Remove a group of manifests using their keys to identify them. If a key
     * is not found, then that removal should be considered successful.
     * @param onRemove A callback for when a manifest is removed from the cell. The key of the manifest will be passed to the callback.
     */
    removeManifests (keys : number [] , onRemove : (a : number ) => any ) : Promise < any > ;
    /**
     * Remove a group of segments using their keys to identify them. If a key
     * is not found, then that removal should be considered successful.
     * @param onRemove A callback for when a segment is removed from the cell. The key of the segment will be passed to the callback.
     */
    removeSegments (keys : number [] , onRemove : (a : number ) => any ) : Promise < any > ;
    /**
     * Updates the given manifest, stored at the given key.
     */
    updateManifest (key : number , manifest : shaka.extern.ManifestDB ) : Promise < any > ;
    /**
     * Replace the expiration time of the manifest stored under |key| with
     * |newExpiration|. If no manifest is found under |key| then this should
     * act as a no-op.
     */
    updateManifestExpiration (key : number , expiration : number ) : Promise < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  /**
   * Storage mechanisms are one of two exported storage APIs. Storage mechanisms
   * are groups of storage cells (shaka.extern.StorageCell). Storage mechanisms
   * are responsible for managing the life cycle of resources shared between
   * storage cells in the same block.
   *
   * For example, a storage mechanism may manage a single database connection
   * while each cell would manage different tables in the database via the same
   * connection.
   */
  interface StorageMechanism {
    /**
     * Free all resources used by the storage mechanism and its cells. This should
     * not affect the stored content.
     */
    destroy ( ) : Promise < any > ;
    /**
     * Erase all content from storage and leave storage in an empty state. Erase
     * may be called with or without |init|.  This allows for storage to be wiped
     * in case of a version mismatch.
     *
     * After calling |erase|, the mechanism will be in an initialized state.
     */
    erase ( ) : Promise < any > ;
    /**
     * Get a map of all the cells managed by the storage mechanism. Editing the
     * map should have no effect on the storage mechanism. The map key is the
     * cell's address in the mechanism and should be consistent between calls to
     * |getCells|.
     */
    getCells ( ) : Map < string , shaka.extern.StorageCell > ;
    /**
     * Get the current EME session storage cell.
     */
    getEmeSessionCell ( ) : shaka.extern.EmeSessionStorageCell ;
    /**
     * Initialize the storage mechanism for first use. This should only be called
     * once. Calling |init| multiple times has an undefined behaviour.
     */
    init ( ) : Promise < any > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type StoredContent = { appMetadata : object | null , duration : number , expiration : number , isIncomplete : boolean , offlineUri : string | null , originalManifestUri : string , size : number , tracks : shaka.extern.TrackList } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline.js
declare namespace shaka.extern {
  type StreamDB = { audioSamplingRate : number | null , channelsCount : number | null , closedCaptions : Map < string , string > | null , codecs : string , encrypted : boolean , external : boolean , forced : boolean , frameRate ? : number , hdr ? : string , height : number | null , id : number , keyIds : Set < string > , kind ? : string , label : string | null , language : string , mimeType : string , originalId : string | null , originalLanguage ? : string | null , pixelAspectRatio ? : string , primary : boolean , roles : string [] , segments : shaka.extern.SegmentDB [] , spatialAudio : boolean , tilesLayout ? : string , type : string , variantIds : number [] , width : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v1.js
declare namespace shaka.extern {
  type ManifestDBV1 = { appMetadata : object | null , drmInfo : shaka.extern.DrmInfo | null , duration : number , expiration : number , key : number , originalManifestUri : string , periods : shaka.extern.PeriodDBV1 [] , sessionIds : string [] , size : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v1.js
declare namespace shaka.extern {
  type PeriodDBV1 = { startTime : number , streams : shaka.extern.StreamDBV1 [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v1.js
declare namespace shaka.extern {
  type SegmentDBV1 = { endTime : number , startTime : number , uri : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v1.js
declare namespace shaka.extern {
  type SegmentDataDBV1 = { data : ArrayBuffer , key : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v1.js
declare namespace shaka.extern {
  type StreamDBV1 = { codecs : string , contentType : string , encrypted : boolean , frameRate ? : number , height : number | null , id : number , initSegmentUri : string | null , keyId : string | null , kind ? : string , label : string | null , language : string , mimeType : string , presentationTimeOffset : number , primary : boolean , segments : shaka.extern.SegmentDBV1 [] , variantIds : number [] , width : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v2.js
declare namespace shaka.extern {
  type ManifestDBV2 = { appMetadata : object | null , drmInfo : shaka.extern.DrmInfo | null , duration : number , expiration : number , originalManifestUri : string , periods : shaka.extern.PeriodDBV2 [] , sessionIds : string [] , size : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v2.js
declare namespace shaka.extern {
  type PeriodDBV2 = { startTime : number , streams : shaka.extern.StreamDBV2 [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v2.js
declare namespace shaka.extern {
  type SegmentDBV2 = { dataKey : number , endTime : number , startTime : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v2.js
declare namespace shaka.extern {
  type SegmentDataDBV2 = { data : ArrayBuffer } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/offline_compat_v2.js
declare namespace shaka.extern {
  type StreamDBV2 = { codecs : string , contentType : string , encrypted : boolean , frameRate ? : number , height : number | null , id : number , initSegmentKey : number | null , keyId : string | null , kind ? : string , label : string | null , language : string , mimeType : string , originalId : string | null , pixelAspectRatio ? : string , presentationTimeOffset : number , primary : boolean , segments : shaka.extern.SegmentDBV2 [] , variantIds : number [] , width : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type AbrConfiguration = { advanced : shaka.extern.AdvancedAbrConfiguration , bandwidthDowngradeTarget : number , bandwidthUpgradeTarget : number , clearBufferSwitch : boolean , defaultBandwidthEstimate : number , enabled : boolean , ignoreDevicePixelRatio : boolean , restrictToElementSize : boolean , restrictToScreenSize : boolean , restrictions : shaka.extern.Restrictions , safeMarginSwitch : number , switchInterval : number , useNetworkInformation : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type AdsConfiguration = { customPlayheadTracker : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type AdvancedAbrConfiguration = { fastHalfLife : number , minBytes : number , minTotalBytes : number , slowHalfLife : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type AdvancedDrmConfiguration = { audioRobustness : string , distinctiveIdentifierRequired : boolean , individualizationServer : string , persistentStateRequired : boolean , serverCertificate : Uint8Array | null , serverCertificateUri : string , sessionType : string , videoRobustness : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type BufferedInfo = { audio : shaka.extern.BufferedRange [] , text : shaka.extern.BufferedRange [] , total : shaka.extern.BufferedRange [] , video : shaka.extern.BufferedRange [] } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type BufferedRange = { end : number , start : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type Chapter = { endTime : number , id : string , startTime : number , title : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type CmcdConfiguration = { contentId : string , enabled : boolean , sessionId : string , useHeaders : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type DashManifestConfiguration = { autoCorrectDrift : boolean , clockSyncUri : string , disableXlinkProcessing : boolean , ignoreDrmInfo : boolean , ignoreEmptyAdaptationSet : boolean , ignoreMaxSegmentDuration : boolean , ignoreMinBufferTime : boolean , ignoreSuggestedPresentationDelay : boolean , initialSegmentLimit : number , keySystemsByURI : { [ key: string ]: string } , manifestPreprocessor : (a : Element ) => any , sequenceMode : boolean , xlinkFailGracefully : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type DrmConfiguration = { advanced : { [ key: string ]: shaka.extern.AdvancedDrmConfiguration } | null , clearKeys : { [ key: string ]: string } , delayLicenseRequestUntilPlayed : boolean , initDataTransform ? : shaka.extern.InitDataTransform , keySystemsMapping : { [ key: string ]: string } , logLicenseExchange : boolean , minHdcpVersion : string , parseInbandPsshEnabled : boolean , persistentSessionOnlinePlayback : boolean , persistentSessionsMetadata : shaka.extern.PersistentSessionMetadata [] , preferredKeySystems : string [] , retryParameters : shaka.extern.RetryParameters , servers : { [ key: string ]: string } , updateExpirationTime : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type DrmSessionMetadata = { initData : Uint8Array | null , initDataType : string | null , sessionId : string , sessionType : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type DrmSupportType = { persistentState : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type EmsgInfo = { endTime : number , eventDuration : number , id : number , messageData : Uint8Array | null , presentationTimeDelta : number , schemeIdUri : string , startTime : number , timescale : number , value : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type HlsManifestConfiguration = { defaultAudioCodec : string , defaultVideoCodec : string , ignoreImageStreamFailures : boolean , ignoreManifestProgramDateTime : boolean , ignoreManifestTimestampsInSegmentsMode : boolean , ignoreTextStreamFailures : boolean , liveSegmentsDelay : number , mediaPlaylistFullMimeType : string , sequenceMode : boolean , useSafariBehaviorForLive : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type ID3Metadata = { cueTime : number | null , data : Uint8Array , dts : number | null , frames : shaka.extern.MetadataFrame [] , pts : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type InitDataTransform = (a : Uint8Array , b : string , c : shaka.extern.DrmInfo | null ) => Uint8Array ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type LanguageRole = { label : string | null , language : string , role : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type LcevcConfiguration = { drawLogo : boolean , dynamicPerformanceScaling : boolean , enabled : boolean , logLevel : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type ManifestConfiguration = { availabilityWindowOverride : number , dash : shaka.extern.DashManifestConfiguration , defaultPresentationDelay : number , disableAudio : boolean , disableText : boolean , disableThumbnails : boolean , disableVideo : boolean , hls : shaka.extern.HlsManifestConfiguration , mss : shaka.extern.MssManifestConfiguration , raiseFatalErrorOnManifestUpdateRequestFailure : boolean , retryParameters : shaka.extern.RetryParameters , segmentRelativeVttTiming : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type MediaQualityInfo = { audioSamplingRate : number | null , bandwidth : number , channelsCount : number | null , codecs : string , contentType : string , frameRate : number | null , height : number | null , mimeType : string | null , pixelAspectRatio : string | null , width : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type MediaSourceConfiguration = { forceTransmux : boolean , insertFakeEncryptionInInit : boolean , sourceBufferExtraFeatures : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type MetadataFrame = { data : ArrayBuffer | null | string | number , description : string , key : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type MetadataRawFrame = { data : Uint8Array | null , size : number , type : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type MssManifestConfiguration = { keySystemsBySystemId : { [ key: string ]: string } , manifestPreprocessor : (a : Element ) => any , sequenceMode : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type OfflineConfiguration = { downloadSizeCallback : (a : number ) => Promise < boolean > , numberOfParallelDownloads : number , progressCallback : (a : shaka.extern.StoredContent , b : number ) => any , trackSelectionCallback : (a : shaka.extern.TrackList ) => Promise < shaka.extern.TrackList > , usePersistentLicense : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type PersistentSessionMetadata = { initData : Uint8Array | null , initDataType : string | null , sessionId : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type PlayerConfiguration = { abr : shaka.extern.AbrConfiguration , abrFactory : shaka.extern.AbrManager.Factory , ads : shaka.extern.AdsConfiguration , autoShowText : shaka.config.AutoShowText , cmcd : shaka.extern.CmcdConfiguration , drm : shaka.extern.DrmConfiguration , lcevc : shaka.extern.LcevcConfiguration , manifest : shaka.extern.ManifestConfiguration , mediaSource : shaka.extern.MediaSourceConfiguration , offline : shaka.extern.OfflineConfiguration , playRangeEnd : number , playRangeStart : number , preferForcedSubs : boolean , preferredAudioChannelCount : number , preferredAudioCodecs : string [] , preferredAudioLabel : string , preferredAudioLanguage : string , preferredDecodingAttributes : string [] , preferredTextLanguage : string , preferredTextRole : string , preferredVariantRole : string , preferredVideoCodecs : string [] , preferredVideoHdrLevel : string , restrictions : shaka.extern.Restrictions , streaming : shaka.extern.StreamingConfiguration , textDisplayFactory : shaka.extern.TextDisplayer.Factory } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type ProducerReferenceTime = { programStartDate : Date | null , wallClockTime : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type Restrictions = { maxBandwidth : number , maxFrameRate : number , maxHeight : number , maxPixels : number , maxWidth : number , minBandwidth : number , minFrameRate : number , minHeight : number , minPixels : number , minWidth : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type StateChange = { duration : number , state : string , timestamp : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type Stats = { bufferingTime : number , completionPercent : number , corruptedFrames : number , decodedFrames : number , drmTimeSeconds : number , droppedFrames : number , estimatedBandwidth : number , gapsJumped : number , height : number , licenseTime : number , liveLatency : number , loadLatency : number , manifestTimeSeconds : number , maxSegmentDuration : number , pauseTime : number , playTime : number , stallsDetected : number , stateHistory : shaka.extern.StateChange [] , streamBandwidth : number , switchHistory : shaka.extern.TrackChoice [] , width : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type StreamingConfiguration = { alwaysStreamText : boolean , autoLowLatencyMode : boolean , bufferBehind : number , bufferingGoal : number , dispatchAllEmsgBoxes : boolean , durationBackoff : number , failureCallback : (a : shaka.util.Error ) => any , forceHTTPS : boolean , gapDetectionThreshold : number , gapJumpTimerTime : number , ignoreTextStreamFailures : boolean , inaccurateManifestTolerance : number , liveSync : boolean , liveSyncMaxLatency : number , liveSyncPlaybackRate : number , lowLatencyMode : boolean , maxDisabledTime : number , observeQualityChanges : boolean , parsePrftBox : boolean , preferNativeHls : boolean , rebufferingGoal : number , retryParameters : shaka.extern.RetryParameters , safeSeekOffset : number , segmentPrefetchLimit : number , stallEnabled : boolean , stallSkip : number , stallThreshold : number , startAtSegmentBoundary : boolean , updateIntervalSeconds : number , useNativeHlsOnSafari : boolean } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type SupportType = { drm : { [ key: string ]: shaka.extern.DrmSupportType | null } , manifest : { [ key: string ]: boolean } , media : { [ key: string ]: boolean } } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type Thumbnail = { duration : number , height : number , imageHeight : number , imageWidth : number , positionX : number , positionY : number , sprite : boolean , startTime : number , uris : string [] , width : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type TimelineRegionInfo = { endTime : number , eventElement : Element | null , id : string , schemeIdUri : string , startTime : number , value : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type Track = { accessibilityPurpose : shaka.media.ManifestParser.AccessibilityPurpose | null , active : boolean , audioBandwidth : number | null , audioCodec : string | null , audioId : number | null , audioMimeType : string | null , audioRoles : string [] | null , audioSamplingRate : number | null , bandwidth : number , channelsCount : number | null , codecs : string | null , forced : boolean , frameRate : number | null , hdr : string | null , height : number | null , id : number , kind : string | null , label : string | null , language : string , mimeType : string | null , originalAudioId : string | null , originalImageId : string | null , originalLanguage : string | null , originalTextId : string | null , originalVideoId : string | null , pixelAspectRatio : string | null , primary : boolean , roles : string [] , spatialAudio : boolean , tilesLayout : string | null , type : string , videoBandwidth : number | null , videoCodec : string | null , videoId : number | null , videoMimeType : string | null , width : number | null } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type TrackChoice = { bandwidth : number | null , fromAdaptation : boolean , id : number , timestamp : number , type : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/player.js
declare namespace shaka.extern {
  type TrackList = shaka.extern.Track [] ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/text.js
declare namespace shaka.extern {
  interface TextDisplayer extends shaka.util.IDestroyable {
    /**
     * Append given text cues to the list of cues to be displayed.
     * @param cues Text cues to be appended.
     */
    append (cues : shaka.text.Cue [] ) : any ;
    destroy ( ) : Promise < any > ;
    /**
     * Returns true if text is currently visible.
     */
    isTextVisible ( ) : boolean ;
    /**
     * Remove all cues that are fully contained by the given time range (relative
     * to the presentation). <code>endTime</code> will be greater to equal to
     * <code>startTime</code>.  <code>remove</code> should only return
     * <code>false</code> if the displayer has been destroyed. If the displayer
     * has not been destroyed <code>remove</code> should return <code>true</code>.
     */
    remove (startTime : number , endTime : number ) : boolean ;
    /**
     * Set text visibility.
     */
    setTextVisibility (on : boolean ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/text.js
declare namespace shaka.extern.TextDisplayer {
  /**
   * A factory for creating a TextDisplayer.
   */
  type Factory = ( ) => shaka.extern.TextDisplayer ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/text.js
declare namespace shaka.extern {
  /**
   * An interface for plugins that parse text tracks.
   */
  interface TextParser {
    /**
     * Parse an initialization segment. Some formats do not have init
     * segments so this won't always be called.
     * @param data The data that makes up the init segment.
     */
    parseInit (data : Uint8Array ) : any ;
    /**
     * Parse a media segment and return the cues that make up the segment.
     * @param data The next section of buffer.
     * @param timeContext The time information that should be used to adjust the times values for each cue.
     */
    parseMedia (data : Uint8Array , timeContext : shaka.extern.TextParser.TimeContext ) : shaka.text.Cue [] ;
    /**
     * Notifies the stream if the manifest is in sequence mode or not.
     */
    setSequenceMode (sequenceMode : boolean ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/text.js
declare namespace shaka.extern.TextParser {
  /**
   * A collection of time offsets used to adjust text cue times.
   */
  type TimeContext = { periodStart : number , segmentEnd : number , segmentStart : number , vttOffset : number } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/text.js
declare namespace shaka.extern {
  type TextParserPlugin = ( ) => shaka.extern.TextParser ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/transmuxer.js
declare namespace shaka.extern {
  /**
   * An interface for transmuxer plugins.
   */
  interface Transmuxer {
    /**
     * For any stream, convert its codecs to MP4 codecs.
     */
    convertCodecs (contentType : string , mimeType : string ) : string ;
    /**
     * Destroy
     */
    destroy ( ) : any ;
    /**
     * Returns the original mimetype of the transmuxer.
     */
    getOrginalMimeType ( ) : string ;
    /**
     * Check if the mime type and the content type is supported.
     */
    isSupported (mimeType : string , contentType ? : string ) : boolean ;
    /**
     * Transmux a input data to MP4.
     * @param reference The segment reference, or null for init segments
     */
    transmux (data : ArrayBuffer | ArrayBufferView , stream : shaka.extern.Stream , reference : shaka.media.SegmentReference | null , duration : number , contentType : string ) : Promise < Uint8Array > ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/shaka/transmuxer.js
declare namespace shaka.extern {
  type TransmuxerPlugin = ( ) => shaka.extern.Transmuxer ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/tippy.js
declare namespace _.clutz {
  /**
   * This is the subset of this method that we use in our demo code.
   */
  function tippy (element : Element , config : object ) : any ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/webkitmediakeys.js
declare namespace _.clutz {
  class WebKitMediaKeyError {
    private noStructuralTyping_WebKitMediaKeyError : any;
    code : number ;
    systemCode : number ;
    static MEDIA_KEYERR_CLIENT : number ;
    static MEDIA_KEYERR_DOMAIN : number ;
    static MEDIA_KEYERR_HARDWARECHANGE : number ;
    static MEDIA_KEYERR_OUTPUT : number ;
    static MEDIA_KEYERR_SERVICE : number ;
    static MEDIA_KEYERR_UNKNOWN : number ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/webkitmediakeys.js
declare namespace _.clutz {
  interface WebKitMediaKeySession extends EventTarget {
    addEventListener (type : any , listener : any , useCapture : any ) : any ;
    close ( ) : any ;
    dispatchEvent (evt : any ) : any ;
    error : WebKitMediaKeyError | null ;
    removeEventListener (type : any , listener : any , useCapture : any ) : any ;
    sessionId : string ;
    update (message : Uint8Array | null ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/externs/webkitmediakeys.js
declare namespace _.clutz {
  class WebKitMediaKeys {
    private noStructuralTyping_WebKitMediaKeys : any;
    constructor (keySystem : string ) ;
    createSession (contentType : string , initData : Uint8Array | null ) : WebKitMediaKeySession ;
    static isTypeSupported (keySystem : string , contentType : string ) : boolean ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  /**
   * Interface for UI elements.  UI elements should inherit from the concrete base
   * class shaka.ui.Element.  The members defined in this extern's constructor are
   * all available from the base class, and are defined here to keep the compiler
   * from renaming them.
   */
  interface IUIElement extends shaka.util.IReleasable {
ad : shaka.extern.IAd | null ;
adManager : shaka.extern.IAdManager | null ;
controls : shaka.ui.Controls | null ;
eventManager : shaka.util.EventManager | null ;
localization : shaka.ui.Localization | null ;
parent : HTMLElement | null ;
player : shaka.Player | null ;
video : HTMLMediaElement | null ;
    release ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern.IUIElement {
  /**
   * A factory for creating a UI element.
   */
  interface Factory {
    create (rootElement : HTMLElement , controls : shaka.ui.Controls ) : shaka.extern.IUIElement ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  /**
   * Interface for UI range elements.  UI range elements should inherit from the
   * concrete base class shaka.ui.RangeElement.  The members defined in this
   * extern's constructor are all available from the base class, and are defined
   * here to keep the compiler from renaming them.
   */
  interface IUIRangeElement extends shaka.extern.IUIElement {
bar : HTMLInputElement ;
container : HTMLElement ;
    changeTo (value : number ) : any ;
    getValue ( ) : number ;
    /**
     * Called when a new value is set by user interaction.
     * To be overridden by subclasses.
     */
    onChange ( ) : any ;
    /**
     * Called when user interaction ends.
     * To be overridden by subclasses.
     */
    onChangeEnd ( ) : any ;
    /**
     * Called when user interaction begins.
     * To be overridden by subclasses.
     */
    onChangeStart ( ) : any ;
    setRange (min : number , max : number ) : any ;
    setValue (value : number ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  /**
   * Interface for SeekBars. SeekBars should inherit from the concrete base
   * class shaka.ui.Element. If you do not need to totaly rebuild the
   * SeekBar, you should consider using shaka.ui.RangeElement or
   * shaka.ui.SeekBar as your base class.
   */
  interface IUISeekBar extends shaka.extern.IUIRangeElement {
    getValue ( ) : number ;
    isShowing ( ) : boolean ;
    setValue (value : number ) : any ;
    /**
     * Called by Controls on a timer to update the state of the seek bar.
     * Also called internally when the user interacts with the input element.
     */
    update ( ) : any ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern.IUISeekBar {
  /**
   * A factory for creating a SeekBar element.
   */
  interface Factory {
    create (rootElement : HTMLElement , controls : shaka.ui.Controls ) : shaka.extern.IUISeekBar ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  /**
   * Interface for UI settings menus.  UI settings menus should inherit from the
   * concrete base class shaka.ui.SettingsMenu.  The members defined in this
   * extern's constructor are all available from the base class, and are defined
   * here to keep the compiler from renaming them.
   */
  interface IUISettingsMenu extends shaka.extern.IUIElement {
backButton : HTMLButtonElement ;
backSpan : HTMLElement ;
button : HTMLButtonElement ;
currentSelection : HTMLElement ;
icon : HTMLElement ;
menu : HTMLElement ;
nameSpan : HTMLElement ;
  }
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  type UIConfiguration = { addBigPlayButton : boolean , addSeekBar : boolean , castAndroidReceiverCompatible : boolean , castReceiverAppId : string , clearBufferOnQualityChange : boolean , contextMenuElements : string [] , controlPanelElements : string [] , customContextMenu : boolean , doubleClickForFullscreen : boolean , enableFullscreenOnRotation : boolean , enableKeyboardPlaybackControls : boolean , enableTooltips : boolean , fadeDelay : number , fastForwardRates : number [] , forceLandscapeOnFullscreen : boolean , fullScreenElement : HTMLElement | null , keyboardLargeSeekDistance : number , keyboardSeekDistance : number , overflowMenuButtons : string [] , playbackRates : number [] , rewindRates : number [] , seekBarColors : shaka.extern.UISeekBarColors , showUnbufferedStart : boolean , singleClickForPlayAndPause : boolean , statisticsList : string [] , trackLabelFormat : shaka.ui.Overlay.TrackLabelFormat , volumeBarColors : shaka.extern.UIVolumeBarColors } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  type UISeekBarColors = { adBreaks : string , base : string , buffered : string , played : string } ;
}
// Generated from /home/joey/hacking/work/shaka-player-clean/ui/externs/ui.js
declare namespace shaka.extern {
  type UIVolumeBarColors = { base : string , level : string } ;
}
